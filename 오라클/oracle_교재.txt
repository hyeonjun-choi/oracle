<1>데이터베이스?
----------------------------------------------------------------------------------------
[검색]이 용이하도록 일정한 기준에 맞추어 자료를 분류, 정리해 놓은 [자료의 집합]
----------------------------------------------------------------------------------------
데이터베이스 조건( 입, 기 )

	실시간 접근성, 지속적인 변화(=최신의 정보가 정확하게 저장), 동시 공유 등
	- 포괄적 개념에서 볼 때, 엑셀 등이 데이터베이스라고 보기 어려움
-----------------------------------------------------------------------------------------
<2>RDBMS (Relational Database Management System, 관계형 데이터베이스 관리 시스템)란? (입)

데이터가 [컬럼(column) - 열]과 [로우(Row) - 행]로 이루어진 [테이블]에 저장되며, 
[테이블]들 사이에 관계를 설정하여 관리하는 S/W 또는 시스템.

RDBMS 제품의 종류
	Oracle 사의 Oracle               --> 대기업용. 현재 대기업 공기업 프로젝트에서 제일 많이 사용되어짐.
	MS 사의 MS-SQL                 --> 대기업용
	Sun Microsystem 사의 MYSQL --> 중소기업용
	Sybase
	DB2 등

고객의 정보를 저장하는 테이블 customer가 있다면 아래와 같은 구조로 데이터를 저장, 관리.

                   customer                                     => 테이블명
------------------------------------------
고객번호      고객명      주소       전화번호              =>column 명
------------------------------------------
  1              저팔계      서울      02-1234-1234       =>row(행)
------------------------------------------
  2              사오정      부산      02-2345-2345       =>row(행)
------------------------------------------
  3              손오공      제주      02-3456-3456       =>row(행)
------------------------------------------
  ↓              ↓          ↓            ↓
column      column      column      column
 (컬럼)       (컬럼)       (컬럼)        (컬럼)
  (열)          (열)         (열)          (열)


<3> SQL(Structured Query Language) - 란?

RDBMS에 접근하여 데이터의 [입력],[수정],[삭제],[검색] 하는 등의 기능을 가진 RDBMS 관리 언어.
<참고>DB, 즉 오라클을 배운다 = SQL 언어를 배우는 것과 동일하다.

특징

▶[절차적 언어]가 아닌 [구조적 언어]이다.
	 
  <참고>절차적(procedural) 언어 (입)
	
▷모든 처리 과정을 일일이 기술하고 기술된 순서대로 로직이 처리되는 언어. (C, Java 등)

 <참고>구조적(structured) 언어 (입)

▷처리 과정을 일일이 기술할 필요 없이 일정한 틀이나 패턴이 있어 맞게 조건들만 
  나열하면 로직이 처리되는 언어.

SQL종류(기, 입)

--------------------------------------------------------------
DDL(Data Definition Language = 데이터 정의 언어)
--------------------------------------------------------------
	객체를 생성, 수정, 삭제 등의 작업 수행
				
	CREATE ==> 객체 생성						] 임의대로 transaction
	ALTER ==>   객체 수정 <주의>update가 아니다. 시험문제 빈도 높음	] 걸 수 없음
	DROP ==>    객체 삭제						] rollback 대상아님
	기타등등
	<주의>오라클에서 객체란 이름을 가지고 저장되는 대상을 객체라 칭함. 자바의 객체와 다름.
	<참고>오라클에서의 객체 - [테이블], [뷰], [트리거], [인덱스], [프로시저], [시퀀스] 등을 말한다.

--------------------------------------------------------------
DML(Data Manipulation Language = 데이터 처리 언어)
--------------------------------------------------------------
	테이블 안의 데이터(객체 아님)를 입력, 수정, 삭제, 검색 등의 작업을 한다.

	INSERT ==> ['행' 단위]의 데이터 입력 <주의> '셀 단위' 데이터 입력 없음. 셀 단위 구분 없음.
	UPDATE ==> ['셀' 단위]의 데이터 수정/삭제
	DELETE ==> ['행' 단위]의 데이터 삭제
	SELECT ==> n행 m열의 데이터 검색 <중요> SQL공부의 90%차지 - DB실력 척도
	기타등등

<문> 셀에 들어있는 데이터를 제거하는 SQL구문은? - UPDATE
<문> 행을 제거하는 SQL구문은? - DELETE
--------------------------------------------------------------
DCL(Data Control Language = 데이터 제어 언어)
--------------------------------------------------------------
	COMMIT     => 트랜잭션 작업 단위의 데이터 입력, 수정, 삭제 작업을 모두 인정.(원래데로 복구할 수 없음) 
	ROLLBACK   => 트랜잭션 작업 단위의 데이터 입력, 수정, 삭제 작업을 모두 취소.
	GRANT       => 접근 제어, 작업권한허용
	REVOKE      => 권한제거
	
<4> 트랜잭션(Transaction)이란 무엇인가(입. 기. 실)

★모두 취소되거나 모두 완료되는 2가지 결과로만 진행되는 작업 단위를 말한다.

★주로 [입력] 또는 [수정] 또는 [삭제] SQL 구문 실행 시 설정

★[목적]이 있어서 [의도]를 가지고 인위적으로 설정

★트랜잭션이 걸린 작업은 가상 작업이 되고 ROLLBACK를 실행하면 모두 취소, COMMIT를 실행하면 
가상작업이 모두 실제로 작업으로 인정된다.

SELECT는 트랜젝션의 대상 아님.(SELECT는 데이터 검색 구문이므로)

트랜잭션 걸고 작성 도중 컴퓨터 꺼졌을 때 - 가상 작업 상태이므로 기본적으로 ROLLBACK

<주의> 트랜잭션이 없는 작업은 N가지 이상의 다양한 결과로 진행 될 수 있다.


<5>오라클에서 [계정] 이란?

오라클에 접속하는 사용자
사용자마다 권한을 다르게 줄수 있다
오라클은 < 다수의 클라이언트에게 동시에 정보를 제공하는 서버 >이므로 
서버의 특징인 [계정]과 [암호]를 가지고 있다.

<참고>서버<SERVER>?

다수의 클라이언트에게 동시에 정보를 제공하는 하드웨어<H/W>나 <S/W>를 말함.

오라클 계정의 종류
-----------------------------------------------------------------------------------------------------------		] 문제 나올
SYS        --> 오라클 설치 시 기본적으로 만들어지는 계정. 모든 것을 할 수 있다. 				] 가능성
-----------------------------------------------------------------------------------------------------------		] 있음
SYSTEM   --> 오라클 설치 시 기본적으로 만들어지는 계정. 모든 것 가능하나. [데이터베이스] 생성 권한 없음.	] (디폴트로
-----------------------------------------------------------------------------------------------------------		] 만들어지는
SCOTT    --> 오라클 설치 시 기본적으로 만들어지는 계정. (구경꾼) 권한 거의 없음.				] 세가지)
-----------------------------------------------------------------------------------------------------------		]
생성 계정 --> 계정 생성 권한을 가진 계정이 만드는 계정이므로 계정별 권한이 설정된다.
	      주로 SYS, SYSTEM 계정 또는 SYS, SYSTEM 계정과 동일한 권한을 가진 계정 만듬.

<6>데이터베이스 차원에서 스키마(Schema)란? (입, 기, 실) 대형 솔루션 회사 시험 타겟

[데이터베이스의 구조]에 대한 정의와 제약조건(데이터가 들어오기 위한 합리적인 조건) 등을 기술한 [명세서].

[계정]이 생성한 모든 [객체]들을 의미 한다. (오라클 객체 => 테이블, 뷰, 인덱스, 프로시저, 트리거 등)

객체들이 DB 구조에 대한 정의와 이에 대한 제약조건 등을 기술한 [명세서]이기 때문이다.

<예시> [KIM]계정이 객체(테이블, 인덱스, 뷰 등)들을 생성했다면 이 객체들 모두를 가리켜 [KIM 스키마]라고 한다.
									[KIM계정으로 들어가서 만든 모든 객체]
생성되는 객체는 [계정명.객체명] 형식으로 저장


<예시>

abc => employee 테이블 생성.  --> abc.employee 형태로 저장

kim => employee 테이블 생성.  --> kim.employee 형태로 저장

abc => employee 테이블 생성.  --> abc.employee 형태로 저장 안됨(이미 동일한 이름 객체 존재하므로)

<7>데이터베이스 차원에서 테이블(table)이란?

RDBMS에서 데이터가 실질적으로 저장되는 [논리적 장소(=S/W적인 장소)]를 말한다.
컬럼(column=열)과 로우(Row열=행=record)로 구성
테이블은 이름가지고 저장되는 객체의 한 종류
개발자 입장에서 제일 손이 많이 가는 객체


테이블에 데이터를 입력하는 SQL이 insert 이다.
테이블에 데이터를 수정하는 SQL이 update 이다.
테이블에 데이터를 삭제하는 SQL이 delete 이다.
테이블에 데이터를 검색하는 SQL이 select 이다. -- 가장 주의. 중요.


<8>테이블(table)을 생성하는 SQL 구문의 형식은?

-----------------------------------------------------------------
CREATE TABLE 테이블명(
	컬럼명1		자료형		제약조건
	, 컬럼명2		자료형		제약조건
	, ~
	, 컬럼명N		자료형		제약조건
);
----------------------------------------------------------------
CREATE TABLE 테이블명(
	컬럼명1		자료형		제약조건,
	컬럼명2		자료형		제약조건,
	~		~		~         ,	
	컬럼명N		자료형		제약조건
);
----------------------------------------------------------------

두가지 형식 존재(앞쪽으로 하는 걸 추천)


(입)
---------------------------------------------------------------------------------------------------------------
자료형(Data type)  => 테이블의 컬럼에 입력될 데이터의 유형을 말함. 문자형, 숫자형, 날짜형 등
---------------------------------------------------------------------------------------------------------------
제약조건 => 입력되는 데이터의 입력 가능 조건을 말함. 제약조건에 위배되는 데이터는 삽입될 수 없다.
(입,시,기)	    제약조건이 생략되면 데이터가 입력되지 않을 경우 null이 저장된다.
---------------------------------------------------------------------------------------------------------------
<주의> 테이블명, 컬럼명 제작 규칙
	▷영문자, 1~9, $, #, _ 로 구성되고 반드시 영문자로 시작해야 한다.
	▷30자를 초과할 수 없다. SQL 예약어(문법상 영단어)는 사용할 수 없다.
	▷하나의 계정이 만든 테이블명은 유일해야 하고 하나의 테이블 안에서 컬럼명은 유일해야 한다.
	▷테이블명, 컬럼명, 제약조건명을 "로 감싸거나 " 없이 그냥 써도 된다.
	▷제약조건 위반 시 셀 뿐만 아니라 한 행 자체가 못 들어간다.
	▷필요에 따라 안 줄 수도 있음.(반드시 부여해야 할 필욘 없다.)
	▷▷▷▷▷▷▷▷▷▷▷▷▷▷▷▷▷▷▷▷ 테이블명, 컬럼명은 가독성 있게 주는 것이 제일 중요


<9> 오라클에서 자료형의 종류
-------------------
CHAR(s)
-------------------
	▶고정길이 문자열 저장, s는 byte수를 의미 
	▶설정 크기보다 입력 문자 크기가 작으면 공백으로 남는다.
	▶설정 크기보다 입력 문자 크기가 크면 못 들어온다.(행 자체가 입력되지 않는다.)
	▶ex, CHAR(4) => 문자 4byte까지 입력가능. 즉, 영문 4개까지, 한글 2개까지 가능.
			<참고> 영문 1자는 1byte 차지, 한글 1자는 2byte 차지.
			ex, 영어 4자, 한글 2자 까지 가능.
	▶항상 일정한 길이의 데이터 들어가야 함.
	▶VARCHAR2에 비해 오라클에 부하주는 양 덜함(크게 신경쓸 정돈 아님)	 		
	▶최대 크기는 2000byte 이다.
	▶CHAR 는 CHAR(1) 과 동일. EX. 성별( W / M )
	▶고객 요구사항으로 인한 변동 요청 시 반영하기 힘듦.

-------------------
VARCHAR2(s)
-------------------
	▶가변길이 문자열 저장. s는 byte수를 의미
	▶설정 크기보다 입력 문자 크기가 작으면 크기가 자동으로 줄어든다.(DB 서버 부담 증가)
	▶설정 크기보다 입력 문자 크기가 크면 행 자체가 입력되지 않는다.
	▶<EX> VARCHAR2(4) => 문자 4byte까지 입력가능. 즉, 영문 4개까지, 한글 2개까지 가능.
	▶보통 테이블을 설계할 때는 CHAR 타입보다는 VARCHAR2 타입을 많이 사용
	  임의의 컬럼의 입력값 길이를 정확하게 예측하더라도 나중에 변경될 가능성이 많기 때문
	▶최대 크기는 4000byte 이다.	
	▶VARCHAR2 만 쓸수 없다. 반드시 byte수 지정해야 함.

-------------------
NUMBER(p,s)
-------------------
	▶정수형 또는 실수형 숫자 저장.
	▶p(precision) => 전체 자릿수(1~38), s(scale) => 소수점이하 자릿수(-84~127) <중요>
	▶s 생략 시 디폴트 0 설정
	▶NUMBER는 즉 p(precision), s(scale) 모두 생략 시 정수, 소수점 이하 자릿수 합쳐 40자리 까지 저장.
	▶소수점 자리수가 넘치면 반올림하고 정수 자리수가 모자라면 오류가 남(행 자체가 입력안됌)
	<예>NUMBER(6,2) 라고 지정한 컬럼에 1234.56 저장하면? -> 1234.56 그대로 저장
	<예>NUMBER(6,2) 라고 지정한 컬럼에 1234.567 저장하면? -> 1234.57 저장. 반올림 한 후 소수점 2자리 까지 저장.
	<예>NUMBER(6,2) 라고 지정한 컬럼에 12345.6 저장하면? -> 저장 오류. 정수 자릿수 부족으로 오류
	<예>NUMBER(3) 라고 지정한 컬럼에 123 저장하면? -> 123저장.
	<예>NUMBER(3) 라고 지정한 컬럼에 123.4 저장하면? -> 123저장. 소수점 1자리에서 반올림해서 저장.
	<예>NUMBER(3) 라고 지정한 컬럼에 1234 저장하면? -> 저장 오류. 정수부문 자릿수 부족으로 오류.

-------------------
DATE
-------------------
	▶[년, 월, 일, 시, 분, 초] 저장.
	▶저장 범위는 BC 4712년 1월 1일~~~~9999년 12월 31일.
	▶<참고>보통 날짜형 데이터는 SQL 문장에는 [TO_CHAR], [TO_DATE] 변환함수와 같이 사용된다. <중요>

	즉, '날짜 모양의 문자'를 '날짜'데이터로 전환하기 위한것

	▶<참고> 2021년 06월 11일 부터 ▶ 2021년 12월 25일 까지 남은 일수 검색하는 SQL 구문 작성?
----------------------------------------------------------------------------------------------------------------------------
	EX).  select to_date('20211225', 'YYYYMMDD')-to_date('20210611', 'YYYYMMDD') from dual
----------------------------------------------------------------------------------------------------------------------------
	▶<참고> 오늘 날짜를 예쁘게 연-월-일 로 검색하는 SQL 구문 작성?
----------------------------------------------------------------------------------------------------------------------------	
	EX).  select to_char(sysdate. 'YYYY-MM-DD') form dual
----------------------------------------------------------------------------------------------------------------------------
	▶<참고>변환함수는 [TO_CHAR], [TO_DATE], [TO_NUMBER], 와 같이 사용된다.


------------------
<참고>기타 문자형에는 CLOB, LONG, NCHAR(s), NVARCHAR2(s), NCLOB 등이 있다.
<참고>기타 숫자형에는 BINARY_FLOAT, BINARY_DOUBLE 도 있다.
<참고>기타 날짜형에는 TIMESTAMP(f), TIMESTAMP(f) WITH TIME ZONE, TIMESTAMP(f) LOCAL WITH TIME ZONE 도 있다.
------------------

<10> 오라클에서 제약조건의 종류는? (입, 기, 실)	

-------------------------
not null
-------------------------
	▶반드시 데이터가 입력돼야 한다. 빈 공간 없어야 함. 필수입력 데이터 이므로.
-------------------------
unique
-------------------------
	▶중복되는 데이터는 입력 불가능하다. 중복해선 안됨.
	▶ex, 주민번호, 전화번호, 직원번호 등등
	▶일반적으로 또는 관용적으로 실무적으로 unique을 가진 컬럼은 not null도 같이 들어간다.
	▶하지만 not null이라고 반드시 unique인 경우는 아니다.
-------------------------
default
-------------------------
	▶데이터를 입력하지 않으면 디폴트로 설정한 값이 입력된다.
	▶ex, 회원가입할 때 가입날짜를 입력하지 않아도 그 당일날짜가 저장되는 경우
	▶자동적으로 not null과 같은 효과가 적용(디폴트 설정 값이 자동으로 채워지므로)
-------------------------
check
-------------------------
	▶지정한 데이터만 입력 가능하다.
	▶ex, 성별 입력 시 남 또는 여 만 입력되는 경우
-------------------------
primary key(PK) <중요, 핵심>
-------------------------
  ㅗ	     |
   |	     |
   |	     |
   |	     |
반드시   	반드시	         ▶not null, unique의 제약조건 성질을 가진다. 즉, 행과 행을 구분할 수 있는 유일한 데이터가 입력된다.
있어야   	있을필요	         ▶차후에 foreign key에 의해 참조 당할 수 있는 키다.
  함	  없음	         ▶행 과 행을 구분할 수 있는 절대 키
   |	     |	         ▶각 테이블 당 하나의 primary key만 설정할 수 있다. 즉, [테이블당 0~1개]만 줄 수 있다.	
   |	     |	         ▶[기본키], [주키]라고도 한다.	
   |	    ㅜ
-------------------------
foreign key(FK) <중요, 핵심>
-------------------------
	▶primary 키에 존재하는 데이터만 삽입될 수 있다. (=primary 키를 참조하는 키다.)
	▶제약조건 위반 시 한 행의 모든 데이터가 입력되지 않음.
	▶각 [테이블 당 0개 이상(여러개)] 만들 수 있다.
	▶<주의>예외적으로 null 값 허용 가능. 즉, 예외적으로 데이터가 입력되지 않을 수 있음.
	▶table과 table간의 관계를 설정하는 키다.
	▶[참조키], [외래키], [관계키], [종속키] 라고도 한다.



<11> 시퀀스(Sequence) 가 무엇?

▶[고유 일련 번호]를 생성해서 제공하는 객체. 일종의 [일련 번호 생성기] 이다.
▶주로 하나의 테이블에서 PRIMARY KEY 로 지정된 컬럼명에 입력될 [일련 번호] 값을 생성한다.
▶(비유)은행에서 번호표 뽑는 기계와 동일한 기능을 가짐.
▶<주의> 개발 과정 도중 중간에 잘못 입력된 데이터로 인한 오류 발생 시 오류 발생으로 인한 번호 누락이 발생됨.

▶시퀀스 생성 SQL 구문

create sequence 시퀀스명
	start with 시작값
	increment by 증가값
	minvalue 최소값
	macvalue 최대값
<예>
create sequence sq_emp
	start with 999
	increment by -1
	minvalue 1
	macvalue 최대값

▶증가된 새 일련번호 얻는 SQL 구문
	시퀀스 명.nextval
▶마지막으로 이미 뽑혔던 일련번호 얻는 SQL 구문
	시퀀스 명.currval
▶시퀀스 삭제 SQL 구문
	drop sequence 시퀀스명;

<12>오라클 연습시 어떤 sw를 설치해야 한는가

<1>개발자 용 오라클 버전(=OracleXE ) 을 설치한다. system 계정의 비밀번호는 123 으로 한다.
<2>오라클 접속 툴의 한 종류인 Sqlgate 를 설치한다. 
<3>Sqlgate 를 실행하고 아래 사항을 입력한 후 접속을 한다, 
	▶IP            => localhost
	▶사용자        => system
	▶암호          => 설정암호
	▶SID(서비스명) => XE

<13> 시스템 계정으로 접속하니 쓸 데 없는 테이블이 많아 번거롭다.
시스템 계정과 동일한 권한을 가지는 새로운 계정을 만들려면?

① system 계정으로 접속한 후 코딩 창에서 아래 와 같은 명령으로 king 계정을 만들고 암호는 k123 으로 한다.
	create user king  identified by k123;
② 아래 와 같은 명령으로 king 계정에 system 계정과 동일한 권한을 부여한다.
	grant connect,resource,dba to king;
③ Sqlgate에서 king 계정으로 재 접속을 시도한 후 아래 사항을 입력한 후 접속을 한다, 
	●IP            => 127.0.0.1 또는 localhost
	●사용자        => king  
	●암호          => k123
	●SID(서비스명) => XE


<14>아래 고객 요구사항에 맞는 테이블을 만들면?

	1. 부서를 관리하고 싶다.
	2. 관리하고 싶은 부서 정보는 부서명, 부서 위치.
	3. 직원정보를 관리하고 싶다.
	4. 관리하고 싶은 직원 정보는 직원명, 직급, 입사일, 소속부서명, 연봉, 주민번호, 연봉등급, 직속상관명.
	5. 고객정보를 관리하고 싶다.
	6. 관리하고 싶은 고객 정보는 고객명, 전화번호, 주민번호, 담당직원명
	7. 연봉등급을 관리하고 싶다.
	8. 관리하고 싶은 연봉 정보는 연봉등급, 등급별 최소연봉, 등급별 최대연봉

SQL_02.sql 참조


<15 ~ 25>(기)
<15> employee 테이블에서 모든 컬럼, 모든 행의 데이터를 검색하면?

-----------------------------------------------------------------------------------------------------------------------------
select emp_no, emp_name, dep_no, jikup, salary, hire_date, jumin_num, phone_num, mgr_emp_no from employee;
-----------------------------------------------------------------------------------------------------------------------------
select * from employee;  (* 사용시 create 구문 그대로 나옴)
-----------------------------------------------------------------------------------------------------------------------------
select 
	emp_no
	, emp_name
	, dep_no
	, jikup
	, salary
	, hire_date
	, jumin_num
	, phone_num
	, mgr_emp_no 
from 
	employee;



<16> employee 테이블에서 emp_no, emp_name, jikup, salary, hire_date 컬럼 데이터 검색하면?

-----------------------------------------------------------------------------------------------------------------------------
select emp_no, emp_name, jikup, salary, hire_date from employee;
-----------------------------------------------------------------------------------------------------------------------------
select 
	emp_no
	, emp_name
	, jikup
	, salary
	, hire_date 
from 
	employee;


<17>  employee 테이블에서 emp_no, emp_name, jikup, salary, hire_date 을 검색하면서 별칭(= alias)을 즉, 헤더를 
	사원번호, 직원명, 직급, 연봉, 입사일로 하고 연봉에 '만원'이란 문자를 붙여 검색하면?

-----------------------------------------------------------------------------------------------------------------------------
select emp_no, emp_name, jikup, salary, hire_date from employee;
-----------------------------------------------------------------------------------------------------------------------------
 
  select
	emp_no		          직원번호  ------------------  테이블에 들어갈 데이터가 아니므로 더블 코트를 사용
	, emp_name	          "직원 명"  ------------------ 가능하면 무조건 더블코트 사용
	, jikup		          "직급"    ------------------ as 생략 가능
	, salary||'만원'		 "연봉"    ------------------ 별칭에 공백 없을시 더블코드 생략 가능
	, hire_date 	      "입사일"  ------------------ 오라클에서 연결연산자는 +가 아니라 ||이다. 자바와 다름.
from
	employee;


<18> employee 테이블에서 직원명, 직급, 연봉, 세금, 실수령액을 검색하면? (세금은 연봉의 12%)

  select
	emp_name           	as "직원명"
	, jikup		            as "직급"
	, salary*0.12||'만원'		as "세금"
	, salary*0.88||'만원'		as "실수령액"
from
	employee;

<19> employee 테이블에서 직급을 중복없이 검색?

select distinct jikup from employee;

select distinct (jikup) from employee;

select unique (jikup) from employee;

<20> employee 테이블에서 부서번호와 직급을 중복없이 검색?

select distinct dep_no, jikup from employee;

<21> employee 테이블에서 연봉이 3000만원 이상인 직원을 검색하면?

select * from employee where salary >= 3000
                                --- <행을 골라내는 키워드>

<22> employee 테이블에서 연봉 오름차순으로 검색하면?

select * from employee order by salary  asc;
                                --- 행의 순서를 바꾸고 싶을때
select * from employee order by salary; ---- asc 생략 가능

select * from employee order by 5 asc;

select * from employee order by 5;

<23>  employee 테이블에서 연봉 내림차순으로 검색하면?

select * from employee order by salary desc; ---- 내림차순. 생략 불가능

select * from employee order by 5 desc;

<24> employee 테이블에서 부서번호 오름차순을 유지하면서 연봉을 내림차순으로 검색

select * from employee order by dep_no asc, salary desc;

select * from employee order by dep_no, salary desc; -- asc생략은 가능하나 전체를 착각하게 만들 가능성 있음

<25> employee 테이블에서 직급이 높은 순서 나열해서 검색하면?

select * from employee order by jikup asc;
select * from employee order by jikup desc;
둘 다 잘못된 예시
직급순서는 인간이 생각하는 기준과 오라클의 정렬기준과 다르기 때문
추후 조건문을 통해 정렬의 기준을 바꿔야 함

select * from employee order by decode( jikup , '사장' ,1, '부장' ,2, '과장' ,3, '대리' , 4), alary desc;
<명심> 고객의 요구사항을 보고 select문을 작성하는 것 또한 중요하지만,
	이미 작성된 select문을 보고 고객의 요구를 알아내는 것 역시 중요함.

<26>employee 테이블에서 부장만 검색?

select * from employee where jikup = '부장'

<27> employee 테이블에서 20번 부서의 과장 검색?

select * from employee where dep_no = 20 and jikup = '과장'

<28> employee 테이블에서 20번 부서 또는 과장 검색?

select * from employee where dep_no = 20 or jikup = '과장'

<29> employee 테이블에서 과장 중에 연봉 3400 이상 검색

select * from employee where jikup = '과장' and salary >= 3400

<30> employee 테이블에서 실수령액 4000만원 이상 받는 직원을 검색. 단, 세금은 12%라 가정.

select * from employee where  salary*0.88>=4000;
 
<31> employee 테이블에서 세금을 제일 많이 내는 직원 순서로 나열하면서 부서번호가 내림차순이면서
사장이 아닌 직원을 검색?

select * from employee where jikup != '사장' order by salary*0.12 desc, dep_no desc;

<32> employee 테이블에서 20번 부서 중에서 연봉 2000~3000 사이 검색하면?

select * from employee where dep_no=20 and salary>=2000 and salary<=3000;    2000<=salary<=3000 - 안됨

select * from employee where dep_no=20 and salary between 2000 and 3000; <참고>

<33> employee 테이블에서 직속상관이 없는 직원 검색

select * from employee where mgr_emp_no = null 

select * from employee where mgr_emp_no is null 

<주의> null값을 찾을 땐 = 을 쓰지 말것

<34> employee 테이블에서 직속상관이 있는 직원 검색

select * from employee where mgr_emp_no is not null

<35> 오라클 4대 천왕

내장함수		=> 미리 만들어진 단위 프로그램으로 호출하면 특정 작업을 하고 데이터를 리턴한다.
join		=> 서로 다른 테이블의 컬럼을 횡으로 붙이는 작업
subquery		=> SQL 구문 안의 select 문
group by		=> 통계 관련 작업

<36> employee 테이블에서 [최소 연봉], [최대 연봉], [평균 연봉], [연봉 총합], [총 인원수]를 검색해서 출력

select
	min( slalry )	as "최소 연봉"  -- salary 컬럼에서 최소값을 리턴
	,max( salary )	as "최대 연봉"  -- salary 컬럼에서 최대값을 리턴
	,avg( salary )	as "평균 연봉"  -- salary 컬럼에서 평균값을 리턴 <조심> avg 사용 시 null 있으면 더할 때 빠지고, 나누는 개수에서도 빠진다
	,sum( salary )	as "연봉 총합"  -- salary 컬럼에서 총합을 리턴
	,count( * )	as "총 인원수"  -- count( * )는 총행의 개수
from
	employee;

<37> 아래 SQL 구문은 무슨 문제의 답인가?
select count(emp_no) from customer;
	==>
담당 직원 있는 고객의 명수
	==>중복을 제거한다면==>
고객을 담당하는 직원의 수

<38> 고객을 담당하고 있는 직원 명수

select count(distinct emp_no) from customer;

<39> 직속상관이 있는 직원의 명수

select count(mgr_emp_no) from employee;

<40> employee 테이블에서 [직원번호], [직원명], [생일월-생일일]를 검색해서 출력

	select
		emp_no						"직원번호"
		, emp_name					"직원명"
		, substr(jumin_num,3,2)||'-'||substr(jumin_num,5,2)	"생일월일"
	from
		employee;

오라클은 인덱스 번호가 없다

substr(컬럼명, 카피해올 데이터의 시작번호, 갯수)

<41> customer 테이블에서 모든 컬럼, 모든 행을 검색해서 출력. 단, 주민번호는 901225-2****** 형태로 출력할것

select
		cus_no						
		, cus_name					
		, tel_num
		, substr(jumin_num,1,6)||'-'||substr(jumin_num,7,1)||'******'
		, emp_no	
	from
		customer;

<43> customer 테이블에서 고객번호, 고객명, 담당직원번호 를 출력하면?
단, 담당직원번호가 없으면 null 출력하지 말고 '없음' 으로 표시

select 
	cus-no
	, cus_name
	, nvl(emp_no||'','없음')
from
	customer;

nvl( 컬럼명, null값일때 대체데이터)
 -- null값 처리 함수. 컬럼명 안의 데이터가 null이 아니면 그냥 리턴하고,
  null값 이면 null값대체데이터를 리턴하는 [null처리 내장함수]이다.
 
<43> customer 테이블에서 고객번호, 고객명, 담당직원존재여부 를 출력하면?
단, 직원번호가 있으면 '있음', 없으면 '없음'으로 표시

select 
	cus-no
	, cus_name
	, nvl2(emp_no, '있음' , '없음')
from
	customer;

nvl2( 컬럼명, null값 아닐때 대체 데이터, null값 일때 대체 데이터 ) 
-- 컬럼명 안의 데이터가 null이 아니면 null값 아닐때 대체데이터로 출력하고
null이면 null값일때 대체데이터를 리턴하는 [null 처리 내장함수] 이다. 
	

<44> employee 테이블에서 직원번호, 직원명, 직급, 성별을 출력하면...

select
	emp_no
	, emp_name
	, jikup
	, case 
		substr(jumin_num,7,1) when '1' then '남' when '3' then '남' when '2' then '여' when '4' then '여' 
	end
from
	employee
----------------------------------------------------------------------------------------------------------------------------------
select
	emp_no
	, emp_name
	, jikup
	, case 
		substr(jumin_num,7,1) when '1' then '남' when '3' then '남' else '여' 
	end
from
	employee
----------------------------------------------------------------------------------------------------------------------------------
select
	emp_no
	, emp_name
	, jikup
	, case 
		when substr(jumin_num,7,1)='1' then '남'
		when substr(jumin_num,7,1)='3' then '남'
		else '여'
	end
from
	employee

----------------------------------------------------------------------------------------------------------------------------------
select
	emp_no
	, emp_name
	, jikup
	, decode(substr(jumin_num,7,1),'1','남','3','남','여')
from
	employee

각 자리수마다 무엇이 있는지 알기 어렵기 때문에 사용에 주의해야

decode 다음 substr시작할때 괄호 반드시 넣어야 함

case = 모든 데이터베이스에서 사용 가능		
		
decode = 오라클에서밖에 못씀 		

case substr(컬럼명, 카피해올 데이터의 시작번호, 갯수) when A then B (else) end


<45> employee 테이블에서 직원번호, 직원명, 직급, 출생년도를 출력


select
	emp_no
	, emp_name
	, jikup
	, case
		when substr( jumin_num,7,1)='1'then'19'||substr(jumin_num,1,2)
		when substr( jumin_num,7,1)='2'then'19'||substr(jumin_num,1,2)
		when substr( jumin_num,7,1)='3'then'20'||substr(jumin_num,1,2)
		when substr( jumin_num,7,1)='4'then'20'||substr(jumin_num,1,2)
	end
from
	employee;
-------------------------->>>
select
	emp_no
	, emp_name
	, jikup
	, case
		when substr( jumin_num,7,1)='1'then'19'
		when substr( jumin_num,7,1)='2'then'19'
		else '20'
		end || substr(jumin_num,1,2)
from
	employee;
--------------------------->>>
select
	emp_no
	, emp_name
	, jikup
	, decode (substr(jumin_num,7,1),'1','19'||substr(jumin_num,1,2),'2','19'||substr(jumin_num,1,2),'20'||substr(jumin_num,1,2))
	, decode (substr(jumin_num,7,1),'1','19','2','19','20'||substr(jumin_num,1,2)) <= 실 정답	
from
	employee;

<46> employee 테이블에서 직원번호, 직원명, 직급, 출생년대(4자리)를 출력

select
	emp_no
	, emp_name
	, jikup
	, case
		when substr( jumin_num,7,1)='1'then'19'
		when substr( jumin_num,7,1)='2'then'19'
		else '20'
		end || substr(jumin_num,1,1)||'0년대'
from
	employee;

<47> employee 테이블에서 나이순으로 출력하면? 연장자가 먼저 나오도록.

select * from employee order by
	case
	when substr( jumin_num,7,1)='1'then'19'
	when substr( jumin_num,7,1)='2'then'19'
	else '20'
	end || substr(jumin_num,1,6)
	asc;

<주의>
select * from employee order by jumin_num asc; - 오류(2000년생이 먼저 나오기 때문. 2000년생은 주민번호가 00으로 시작.

<48> employee 테이블에서 직급순서대로 정렬하여 모든 컬럼을 보이면?

select * from employee order by 
	case jikup 
		when '사장' then 1
		when '부장' then 2
		when '과장' then 3
		when '대리' then 4
		when '주임' then 5 else 6
	end
	asc;

<49> employee 테이블에서 직원번호, 직원명, 입사일(년-월-일) 검색

select 
	emp_no
	, emp_name
	, to_char(hire_date,'YYYY-MM-DD') 
from 
	employee;

-------------------------------------------------------------------------------------------
to_char( 날짜 또는 숫자, '출력문자패턴' )
문자데이터가 아닌 데이터를 작성자가 원하는 데이터로 전환할 때 필요.
지정한 날짜 또는 숫자를 원하는 출력문자패턴 으로 바꾸어 주는 변환함수의 일종




<50> employee 테이블에서 직원번호, 직원명, 나이 검색

select 
	emp_no
	, emp_name
	, to_number(to_char(sysdate, 'YYYY')) 
- to_number( 
	case
	substr( jumin_num,7,1) when '1' then'19' when '2' then '19' else '20' end 
	|| substr(jumin_num,1,2)) 
	+ 1||'세'
from 
	employee;

<51> employee 테이블에서 직원번호, 직원명, 근무년차를 검색 출력

select 
	emp_no
	, emp_name
	, 오늘날짜에서 입사일 날짜까지의 차이를 일수로 구한 다음 365로 나눈 후 소수 첫째 자리에서 무조건 올림
from employee;
----------------------------------------------------------------------------------------------------------------------------

select 
	emp_no					"직원번호"
	, emp_name				"직원명"
	, ceil( (sysdate-hire_date)/365 )||'년차'		"근무년차"
from employee;
----------------------------------------------------------------------------------------------------------------------------
★오라클은 날짜-날짜 의 결과값은 날짜차이만큼의 일수이다
ceil(~)  	=> 소수 첫째 자리에서 무조건 올림해서 리턴하는 수학 함수의 일종이다. (숫자 자료형의 칼럼을 끌어안고)
floor(~) 	=> 소수 첫째 자리에서 무조건 내림해서 리턴하는 수학 함수의 일종이다.

<참고> 오라클은 날짜 데이터에서 날짜 데이터를 빼면 그 차이만큼을 일 수로 리턴하는 특징 있음.(전용 함수가 없기 때문)
	더하는 건 아예 없음.

<52> employee 테이블에서 직원번호, 직원명, 연령대를 검색해서 출력하면

select 
	emp_no					
	, emp_name				
	,
	floor(	(
	to_number( to_char(sysdate, 'YYYY')) 
	- to_number( case substr( jumin_num,7,1) when '1' then'19' when '2' then '19' else '20' end 
	|| substr(jumin_num,1,2)
	)+ 1
	)*0.1
	)||'0대'
		
from employee;

<53>  employee 테이블에서 직원번호, 직원명, 100일잔치 날짜를 검색해서 출력하면

select 
	emp_no					
	, emp_name				
	, to_char(
		to_date(
			case when substr ( jumin_num,7,1 ) in('1', '2' ) then '19' else '20' end
				 ||substr(jumin_num,1,6)
				, 'YYYYMMDD' 
				)+100
				, 'YYYY-MM-DD'
		)	
from 
	employee;

<54> 개강일이 2021년 5월 12일 이고 종강일이 2021년 11월 10일 이다. 몇일 동안 학원 생활

select
	to_date('20211110', 'YYYYMMDD')
	-
	to_date('20210512', 'YYYYMMDD')
from
	dual;

날짜끼리 빼는 함수 공식
to_date('큰 날짜', 'YYYYMMDD') - to_date('작은 날짜', 'YYYYMMDD')


dual(가상 혹은 더미 테이블) - 존재되어 있는 테이블이 있지 않는 경우


<참고>
~~ where dep_no = 10 or dep_no = 20;
~~ where dep_no in(10,20);


<참고>오라클은 날짜에다가 정수를 더하거나 빼면 정수 만큼의 날짜가 더하거나 빼져 날짜 취급된다(전용 함수 없음)

<55> employee 테이블에서 직원번호, 직원명, 현재나이, 입사일 당시나이를 검색해서 출력

select
	emp_no
	, emp_name
	, to_number(to_char(sysdate, 'YYYY'))
	- to_number(
	case
	substr( jumin_num,7,1) when '1' then'19' when '2' then '19' else '20' end
	|| substr(jumin_num,1,2))
	+ 1||'세'
		, to_number(to_char(hire_date, 'YYYY'))
	- to_number(
	case
	substr( jumin_num,7,1) when '1' then'19' when '2' then '19' else '20' end
	|| substr(jumin_num,1,2))
	+ 1||'세'

from
employee;

<56> employee 테이블에서 직원번호, 직원명, 주민번호, 다가올생일날( 년-월-일 ), 생일까지 남은 일수를 검색하면?

select
	emp_no
	, emp_name
	, jumin_num
	, case when to date(sysdate, 'MMDD') - todate(jumin_num, 'MMDD')


올해 생일을 찍는 경우 생일이 지금 이 시간보다 이후면 올해 생일 찍어야, 지금 이 시간보다 이전이면 내년 생일을 찍어야

<주의> null값 있는 데이터 검색 = is , null값 없는 데이터 검색 = is not 

원본데이터에는 곱하기등의 다른 행동이 가해지지 않음

create table dept(						]
 dep_no      	number(3)     	 			]
 ,dep_name  	varchar2(20)    	 not null unique		] 중요
 ,loc       	varchar2(20)   	 not null			]
 ,primary key(dep_no)					]
);							]

-------중요-------
Insert <into> dept(dep_no, dep_name, loc) values(10, '청무부', '서울');
Insert into dept(dep_no, dep_name, loc) values(20, '영업부', '부산');
Insert into dept(dep_no, dep_name, loc) values(30, '전산부', '대전');
Insert into dept(dep_no, dep_name, loc) values(40, '자재부', '광주');

select * from dept

commit;

drop table dept;

 create table employee(
   emp_no           number(3)
   ,emp_name       varchar2(20)     not null
   ,dep_no           number(3)
   ,jikup       	varchar2(20)     not null
   ,salary     	number(9)       default 0
   ,hire_date   	date              default  sysdate
   ,jumin_num       char(13)          not null unique
   ,phone_num      varchar2(15)     not null
   ,mgr_emp_no    number(3)

   , primary key(emp_no)
   , foreign key(dep_no) references dept(dep_no)
   , constraint employee_mgr_emp_no_fk foreign key(mgr_emp_no) references employee(emp_no)
);

 select * from employee;

 --fk 제약조건 끄기
alter table employee disable constraint employee_mgr_emp_no_fk;

  --------------------------------------------
--●날짜 데이터는 '년-월-일'  로 입력 가능하게 하기
--------------------------------------------
alter session set nls_date_format = 'yyyy-mm-dd' ;

--------중요-------
insert <into> employee values( 1, '홍길동', 10, '사장', 5000, '1980-01-01', '7211271109410', '01099699515', null );
insert into employee values( 2, '한국남', 20, '부장', 3000, '1988-11-01', '6002061841224', '01024948424', 1 );
insert into employee values( 3, '이순신', 20, '과장', 3500, '1989-03-01', '6209172010520', '01026352672', 2 );
insert into employee values( 4, '이미라', 30, '대리', 2503, '1983-04-01', '8409282070226', '01094215694', 17 );
insert into employee values( 5, '이순라', 20, '사원', 1200, '1990-05-01', '8401041483626', '01028585900', 3 );
insert into employee values( 6, '공부만', 30, '과장', 4003, '1995-05-01', '8402121563616', '01191338328', 17 );
insert into employee values( 7, '놀기만', 20, '과장', 2300, '1996-06-01', '8011221713914', '01029463523', 2 );
insert into employee values( 8, '채송화', 30, '대리', 1703, '1992-06-01', '8105271014112', '01047111052', 17 );
insert into employee values( 9, '무궁화', 10, '사원', 1100, '1984-08-01', '8303291319116', '01025672300', 12 );
insert into employee values( 10, '공부해', 30, '사원', 1303, '1988-11-01', '8410031281312', '01027073174', 4 );
insert into employee values( 11, '류별나', 20, '과장', 1600, '1989-12-01', '8409181463545', '01071628290', 2 );
insert into employee values( 12, '류명한', 10, '대리', 1800, '1990-10-01', '8207211661117', '01042072622', 20 );
insert into employee values( 13, '무궁화', 10, '부장', 3000, '1996-11-01', '8603231183011', '01098110955', 1 );
insert into employee values( 14, '채시라', 20, '사원', 3400, '1993-10-01', '8001172065410', '01044452437', 3 );
insert into employee values( 15, '최진실', 10, '사원', 2000, '1991-04-01', '8303101932611', '01027491145', 12 );
insert into employee values( 16, '김유신', 30, '사원', 4000, '1981-04-01', '7912031009014', '01098218448', 4 );
insert into employee values( 17, '이성계', 30, '부장', 2803, '1984-05-01', '8102261713921', '0165358075', 1 );
insert into employee values( 18, '강감찬', 30, '사원', 1003, '1986-07-01', '8203121977315', '01033583130', 4 );
insert into employee values( 19, '임꺽정', 20, '사원', 2200, '1988-04-01', '8701301040111', '01086253078', 7 );
insert into employee values( 20, '깨똥이', 10, '과장', 4500, '1990-05-01', '8811232452719', '01090084876', 13 );

commit;
drop table employee;
delete from employee;


<틀린 예시>
create table employee(
     emp_no        number(3)
    ,emp_name      varchar2(20) not null
    ,dep_no        number(3)
    ,jikup         varchar2(20) not null
    ,salary        number(9) default 0
    ,hire_date     date   default sysdate
    ,jumin_num     char(13) not null unique
    ,phone         varchar2(15) not null
    ,mgr_emp_no    number(3)   
    
    
    ,primary key(emp_no)
    ,foreign key(dep_no) references dept(dep_no)
    ,constraint employee_mgr_emp_no_fk foreign key(mgr_emp_no) references employee(dep_no) - foreign key와 primary key 순서 주의
);

















dept 
=====================================================
dep_no(PK)     dep_name   
=====================================================
10             관리부		---- 지울 수 없음
20             자재부		---- 지울 수 없음
30             홍보부		---- 지울 수 없음
40             사업부		---- 지울 수 없음
50 	    전략부			---- 지울 수 있음 ( 참조하는 FK구간에 해당되는 행이 없으므로)

                  employee 
===============================================================
e_no(PK)     e_name    dep_no(FK)    salary  jikup     mgr_e_no(FK) 
===============================================================
1         사오정       10            5000     대리       3
2         저팔계       20            6000     과장       3
3         손오공       30            7000     부장       null
4         사오정       40            5000     대리       2


            customer 
=====================================================
c_no(PK)     c_name    phone  e_no(FK)
=====================================================
1         사오순        ~     2
2         저팔순        ~     4
3         손오순        ~     1
4         사오순        ~     2


---------------------------------------------------
FK 가 있으면 반드시 PK 가 있다.
---------------------------------------------------
unique 가 걸린 컬럼에는 반드시 not null 이 걸린다..
---------------------------------------------------
자료형도 데이터를 걸러내는데 사용된다.
---------------------------------------------------
not null 이 걸린 컬럼에는 반드시  unique 가 걸린다..
---------------------------------------------------
셀을 삭제하는 명령어는 update 이다.
---------------------------------------------------
행 삭제는 alter 구문이다.
---------------------------------------------------
행 수정은 update 구문이다.
---------------------------------------------------
create 로 만든 테이블은 rollback 으로 없앨수 있다.
---------------------------------------------------
select 도 트랜잭션을 걸수 있다.
---------------------------------------------------
default 가 걸리면 대부분 not null 이다.


포트 번호 :
운영체제에 설치되는 소프트웨어가 통신을 목적으로 운영체제로부터 부여받는 통신번호

	'20211225' - '20210611' --> XX


★
현업 개발 일지를 일기 형식으로
메모하는 습관 필요

★
Q 자바에서 " 와 ' 가 언제 사용되는지?
String 형 데이터 에 "
char형 문자 데이터(길이 한자로 해야) 에 '


★
ID - 모든 사람이 균등하게 환경 사용
계정 - 개인마다 다른 권한 부여


★철자 주의
컬럼 Column,
트랜잭션 Transaction,
스키마 Schema
질문 Query
절차적 Procedural

★
String name = "아무개";
int age = 5555555;
--------------------------------------------
select b_no , subject from board;

★. 면접 팁 ;
정의, 부연, 예시

정리정돈된 대화 습관--------------------------------------------------------------------

