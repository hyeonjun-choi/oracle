<1>데이터베이스?
----------------------------------------------------------------------------------------
[검색]이 용이하도록 일정한 기준에 맞추어 자료를 분류, 정리해 놓은 [자료의 집합]
----------------------------------------------------------------------------------------
데이터베이스 조건( 입, 기 )

	실시간 접근성, 지속적인 변화(=최신의 정보가 정확하게 저장), 동시 공유 등
	- 포괄적 개념에서 볼 때, 엑셀 등이 데이터베이스라고 보기 어려움
-----------------------------------------------------------------------------------------
<2>RDBMS (Relational Database Management System, 관계형 데이터베이스 관리 시스템)란? (입)

데이터가 [컬럼(column) - 열]과 [로우(Row) - 행]로 이루어진 [테이블]에 저장되며, 
[테이블]들 사이에 관계를 설정하여 관리하는 S/W 또는 시스템.

RDBMS 제품의 종류
	Oracle 사의 Oracle               --> 대기업용. 현재 대기업 공기업 프로젝트에서 제일 많이 사용되어짐.
	MS 사의 MS-SQL                 --> 대기업용
	Sun Microsystem 사의 MYSQL --> 중소기업용
	Sybase
	DB2 등

고객의 정보를 저장하는 테이블 customer가 있다면 아래와 같은 구조로 데이터를 저장, 관리.

                   customer                                     => 테이블명
------------------------------------------
고객번호      고객명      주소       전화번호              =>column 명
------------------------------------------
  1              저팔계      서울      02-1234-1234       =>row(행)
------------------------------------------
  2              사오정      부산      02-2345-2345       =>row(행)
------------------------------------------
  3              손오공      제주      02-3456-3456       =>row(행)
------------------------------------------
  ↓              ↓          ↓            ↓
column      column      column      column
 (컬럼)       (컬럼)       (컬럼)        (컬럼)
  (열)          (열)         (열)          (열)


<3> SQL(Structured Query Language) - 란?

RDBMS에 접근하여 데이터의 [입력],[수정],[삭제],[검색] 하는 등의 기능을 가진 RDBMS 관리 언어.
<참고>DB, 즉 오라클을 배운다 = SQL 언어를 배우는 것과 동일하다.

특징

▶[절차적 언어]가 아닌 [구조적 언어]이다.
	 
  <참고>절차적(procedural) 언어 (입)
	
▷모든 처리 과정을 일일이 기술하고 기술된 순서대로 로직이 처리되는 언어. (C, Java 등)

 <참고>구조적(structured) 언어 (입)

▷처리 과정을 일일이 기술할 필요 없이 일정한 틀이나 패턴이 있어 맞게 조건들만 
  나열하면 로직이 처리되는 언어.

SQL종류(기, 입)

--------------------------------------------------------------
DDL(Data Definition Language = 데이터 정의 언어)
--------------------------------------------------------------
	객체를 생성, 수정, 삭제 등의 작업 수행
				
	CREATE ==> 객체 생성						] 임의대로 transaction
	ALTER ==>   객체 수정 <주의>update가 아니다. 시험문제 빈도 높음	] 걸 수 없음
	DROP ==>    객체 삭제						] rollback 대상아님
	기타등등
	<주의>오라클에서 객체란 이름을 가지고 저장되는 대상을 객체라 칭함. 자바의 객체와 다름.
	<참고>오라클에서의 객체 - [테이블], [뷰], [트리거], [인덱스], [프로시저], [시퀀스] 등을 말한다.

--------------------------------------------------------------
DML(Data Manipulation Language = 데이터 처리 언어)
--------------------------------------------------------------
	테이블 안의 데이터(객체 아님)를 입력, 수정, 삭제, 검색 등의 작업을 한다.

	INSERT ==> ['행' 단위]의 데이터 입력 <주의> '셀 단위' 데이터 입력 없음. 셀 단위 구분 없음.
	UPDATE ==> ['셀' 단위]의 데이터 수정/삭제
	DELETE ==> ['행' 단위]의 데이터 삭제
	SELECT ==> n행 m열의 데이터 검색 <중요> SQL공부의 90%차지 - DB실력 척도
	기타등등

<문> 셀에 들어있는 데이터를 제거하는 SQL구문은? - UPDATE
<문> 행을 제거하는 SQL구문은? - DELETE
--------------------------------------------------------------
DCL(Data Control Language = 데이터 제어 언어)
--------------------------------------------------------------
	COMMIT     => 트랜잭션 작업 단위의 데이터 입력, 수정, 삭제 작업을 모두 인정.(원래데로 복구할 수 없음) 
	ROLLBACK   => 트랜잭션 작업 단위의 데이터 입력, 수정, 삭제 작업을 모두 취소.
	GRANT       => 접근 제어, 작업권한허용
	REVOKE      => 권한제거
	
<4> 트랜잭션(Transaction)이란 무엇인가(입. 기. 실)

★모두 취소되거나 모두 완료되는 2가지 결과로만 진행되는 작업 단위를 말한다.

★주로 [입력] 또는 [수정] 또는 [삭제] SQL 구문 실행 시 설정

★[목적]이 있어서 [의도]를 가지고 인위적으로 설정

★트랜잭션이 걸린 작업은 가상 작업이 되고 ROLLBACK를 실행하면 모두 취소, COMMIT를 실행하면 
가상작업이 모두 실제로 작업으로 인정된다.

SELECT는 트랜젝션의 대상 아님.(SELECT는 데이터 검색 구문이므로)

트랜잭션 걸고 작성 도중 컴퓨터 꺼졌을 때 - 가상 작업 상태이므로 기본적으로 ROLLBACK

<주의> 트랜잭션이 없는 작업은 N가지 이상의 다양한 결과로 진행 될 수 있다.


<5>오라클에서 [계정] 이란?

오라클에 접속하는 사용자
사용자마다 권한을 다르게 줄수 있다
오라클은 < 다수의 클라이언트에게 동시에 정보를 제공하는 서버 >이므로 
서버의 특징인 [계정]과 [암호]를 가지고 있다.

<참고>서버<SERVER>?

다수의 클라이언트에게 동시에 정보를 제공하는 하드웨어<H/W>나 <S/W>를 말함.

오라클 계정의 종류
-----------------------------------------------------------------------------------------------------------		] 문제 나올
SYS        --> 오라클 설치 시 기본적으로 만들어지는 계정. 모든 것을 할 수 있다. 				] 가능성
-----------------------------------------------------------------------------------------------------------		] 있음
SYSTEM   --> 오라클 설치 시 기본적으로 만들어지는 계정. 모든 것 가능하나. [데이터베이스] 생성 권한 없음.	] (디폴트로
-----------------------------------------------------------------------------------------------------------		] 만들어지는
SCOTT    --> 오라클 설치 시 기본적으로 만들어지는 계정. (구경꾼) 권한 거의 없음.				] 세가지)
-----------------------------------------------------------------------------------------------------------		]
생성 계정 --> 계정 생성 권한을 가진 계정이 만드는 계정이므로 계정별 권한이 설정된다.
	      주로 SYS, SYSTEM 계정 또는 SYS, SYSTEM 계정과 동일한 권한을 가진 계정 만듬.

<6>데이터베이스 차원에서 스키마(Schema)란? (입, 기, 실) 대형 솔루션 회사 시험 타겟

[데이터베이스의 구조]에 대한 정의와 제약조건(데이터가 들어오기 위한 합리적인 조건) 등을 기술한 [명세서].

[계정]이 생성한 모든 [객체]들을 의미 한다. (오라클 객체 => 테이블, 뷰, 인덱스, 프로시저, 트리거 등)

객체들이 DB 구조에 대한 정의와 이에 대한 제약조건 등을 기술한 [명세서]이기 때문이다.

<예시> [KIM]계정이 객체(테이블, 인덱스, 뷰 등)들을 생성했다면 이 객체들 모두를 가리켜 [KIM 스키마]라고 한다.
									[KIM계정으로 들어가서 만든 모든 객체]
생성되는 객체는 [계정명.객체명] 형식으로 저장


<예시>

abc => employee 테이블 생성.  --> abc.employee 형태로 저장

kim => employee 테이블 생성.  --> kim.employee 형태로 저장

abc => employee 테이블 생성.  --> abc.employee 형태로 저장 안됨(이미 동일한 이름 객체 존재하므로)

<7>데이터베이스 차원에서 테이블(table)이란?

RDBMS에서 데이터가 실질적으로 저장되는 [논리적 장소(=S/W적인 장소)]를 말한다.
컬럼(column=열)과 로우(Row열=행=record)로 구성
테이블은 이름가지고 저장되는 객체의 한 종류
개발자 입장에서 제일 손이 많이 가는 객체


테이블에 데이터를 입력하는 SQL이 insert 이다.
테이블에 데이터를 수정하는 SQL이 update 이다.
테이블에 데이터를 삭제하는 SQL이 delete 이다.
테이블에 데이터를 검색하는 SQL이 select 이다. -- 가장 주의. 중요.


<8>테이블(table)을 생성하는 SQL 구문의 형식은?

-----------------------------------------------------------------
CREATE TABLE 테이블명(
	컬럼명1		자료형		제약조건
	, 컬럼명2		자료형		제약조건
	, ~
	, 컬럼명N		자료형		제약조건
);
----------------------------------------------------------------
CREATE TABLE 테이블명(
	컬럼명1		자료형		제약조건,
	컬럼명2		자료형		제약조건,
	~		~		~         ,	
	컬럼명N		자료형		제약조건
);
----------------------------------------------------------------

두가지 형식 존재(앞쪽으로 하는 걸 추천)


(입)
---------------------------------------------------------------------------------------------------------------
자료형(Data type)  => 테이블의 컬럼에 입력될 데이터의 유형을 말함. 문자형, 숫자형, 날짜형 등
---------------------------------------------------------------------------------------------------------------
제약조건 => 입력되는 데이터의 입력 가능 조건을 말함. 제약조건에 위배되는 데이터는 삽입될 수 없다.
(입,시,기)	    제약조건이 생략되면 데이터가 입력되지 않을 경우 null이 저장된다.
---------------------------------------------------------------------------------------------------------------
<주의> 테이블명, 컬럼명 제작 규칙
	▷영문자, 1~9, $, #, _ 로 구성되고 반드시 영문자로 시작해야 한다.
	▷30자를 초과할 수 없다. SQL 예약어(문법상 영단어)는 사용할 수 없다.
	▷하나의 계정이 만든 테이블명은 유일해야 하고 하나의 테이블 안에서 컬럼명은 유일해야 한다.
	▷테이블명, 컬럼명, 제약조건명을 "로 감싸거나 " 없이 그냥 써도 된다.
	▷제약조건 위반 시 셀 뿐만 아니라 한 행 자체가 못 들어간다.
	▷필요에 따라 안 줄 수도 있음.(반드시 부여해야 할 필욘 없다.)
	▷▷▷▷▷▷▷▷▷▷▷▷▷▷▷▷▷▷▷▷ 테이블명, 컬럼명은 가독성 있게 주는 것이 제일 중요


<9> 오라클에서 자료형의 종류
-------------------
CHAR(s)
-------------------
	▶고정길이 문자열 저장, s는 byte수를 의미 
	▶설정 크기보다 입력 문자 크기가 작으면 공백으로 남는다.
	▶설정 크기보다 입력 문자 크기가 크면 못 들어온다.(행 자체가 입력되지 않는다.)
	▶ex, CHAR(4) => 문자 4byte까지 입력가능. 즉, 영문 4개까지, 한글 2개까지 가능.
			<참고> 영문 1자는 1byte 차지, 한글 1자는 2byte 차지.
			ex, 영어 4자, 한글 2자 까지 가능.
	▶항상 일정한 길이의 데이터 들어가야 함.
	▶VARCHAR2에 비해 오라클에 부하주는 양 덜함(크게 신경쓸 정돈 아님)	 		
	▶최대 크기는 2000byte 이다.
	▶CHAR 는 CHAR(1) 과 동일. EX. 성별( W / M )
	▶고객 요구사항으로 인한 변동 요청 시 반영하기 힘듦.

-------------------
VARCHAR2(s)
-------------------
	▶가변길이 문자열 저장. s는 byte수를 의미
	▶설정 크기보다 입력 문자 크기가 작으면 크기가 자동으로 줄어든다.(DB 서버 부담 증가)
	▶설정 크기보다 입력 문자 크기가 크면 행 자체가 입력되지 않는다.
	▶<EX> VARCHAR2(4) => 문자 4byte까지 입력가능. 즉, 영문 4개까지, 한글 2개까지 가능.
	▶보통 테이블을 설계할 때는 CHAR 타입보다는 VARCHAR2 타입을 많이 사용
	  임의의 컬럼의 입력값 길이를 정확하게 예측하더라도 나중에 변경될 가능성이 많기 때문
	▶최대 크기는 4000byte 이다.	
	▶VARCHAR2 만 쓸수 없다. 반드시 byte수 지정해야 함.

-------------------
NUMBER(p,s)
-------------------
	▶정수형 또는 실수형 숫자 저장.
	▶p(precision) => 전체 자릿수(1~38), s(scale) => 소수점이하 자릿수(-84~127) <중요>
	▶s 생략 시 디폴트 0 설정
	▶NUMBER는 즉 p(precision), s(scale) 모두 생략 시 정수, 소수점 이하 자릿수 합쳐 40자리 까지 저장.
	▶소수점 자리수가 넘치면 반올림하고 정수 자리수가 모자라면 오류가 남(행 자체가 입력안됌)
	<예>NUMBER(6,2) 라고 지정한 컬럼에 1234.56 저장하면? -> 1234.56 그대로 저장
	<예>NUMBER(6,2) 라고 지정한 컬럼에 1234.567 저장하면? -> 1234.57 저장. 반올림 한 후 소수점 2자리 까지 저장.
	<예>NUMBER(6,2) 라고 지정한 컬럼에 12345.6 저장하면? -> 저장 오류. 정수 자릿수 부족으로 오류
	<예>NUMBER(3) 라고 지정한 컬럼에 123 저장하면? -> 123저장.
	<예>NUMBER(3) 라고 지정한 컬럼에 123.4 저장하면? -> 123저장. 소수점 1자리에서 반올림해서 저장.
	<예>NUMBER(3) 라고 지정한 컬럼에 1234 저장하면? -> 저장 오류. 정수부문 자릿수 부족으로 오류.

-------------------
DATE
-------------------
	▶[년, 월, 일, 시, 분, 초] 저장.
	▶저장 범위는 BC 4712년 1월 1일~~~~9999년 12월 31일.
	▶<참고>보통 날짜형 데이터는 SQL 문장에는 [TO_CHAR], [TO_DATE] 변환함수와 같이 사용된다. <중요>

	즉, '날짜 모양의 문자'를 '날짜'데이터로 전환하기 위한것

	▶<참고> 2021년 06월 11일 부터 ▶ 2021년 12월 25일 까지 남은 일수 검색하는 SQL 구문 작성?
----------------------------------------------------------------------------------------------------------------------------
	EX).  select to_date('20211225', 'YYYYMMDD')-to_date('20210611', 'YYYYMMDD') from dual
----------------------------------------------------------------------------------------------------------------------------
	▶<참고> 오늘 날짜를 예쁘게 연-월-일 로 검색하는 SQL 구문 작성?
----------------------------------------------------------------------------------------------------------------------------	
	EX).  select to_char(sysdate. 'YYYY-MM-DD') form dual
----------------------------------------------------------------------------------------------------------------------------
	▶<참고>변환함수는 [TO_CHAR], [TO_DATE], [TO_NUMBER], 와 같이 사용된다.


------------------
<참고>기타 문자형에는 CLOB, LONG, NCHAR(s), NVARCHAR2(s), NCLOB 등이 있다.
<참고>기타 숫자형에는 BINARY_FLOAT, BINARY_DOUBLE 도 있다.
<참고>기타 날짜형에는 TIMESTAMP(f), TIMESTAMP(f) WITH TIME ZONE, TIMESTAMP(f) LOCAL WITH TIME ZONE 도 있다.
------------------

<10> 오라클에서 제약조건의 종류는? (입, 기, 실)	

-------------------------
not null
-------------------------
	▶반드시 데이터가 입력돼야 한다. 빈 공간 없어야 함. 필수입력 데이터 이므로.
-------------------------
unique
-------------------------
	▶중복되는 데이터는 입력 불가능하다. 중복해선 안됨.
	▶ex, 주민번호, 전화번호, 직원번호 등등
	▶일반적으로 또는 관용적으로 실무적으로 unique을 가진 컬럼은 not null도 같이 들어간다.
	▶하지만 not null이라고 반드시 unique인 경우는 아니다.
-------------------------
default
-------------------------
	▶데이터를 입력하지 않으면 디폴트로 설정한 값이 입력된다.
	▶ex, 회원가입할 때 가입날짜를 입력하지 않아도 그 당일날짜가 저장되는 경우
	▶자동적으로 not null과 같은 효과가 적용(디폴트 설정 값이 자동으로 채워지므로)
-------------------------
check
-------------------------
	▶지정한 데이터만 입력 가능하다.
	▶ex, 성별 입력 시 남 또는 여 만 입력되는 경우
-------------------------
primary key(PK) <중요, 핵심>
-------------------------
  ㅗ	     |
   |	     |
   |	     |
   |	     |
반드시   	반드시	         ▶not null, unique의 제약조건 성질을 가진다. 즉, 행과 행을 구분할 수 있는 유일한 데이터가 입력된다.
있어야   	있을필요	         ▶차후에 foreign key에 의해 참조 당할 수 있는 키다.
  함	  없음	         ▶행 과 행을 구분할 수 있는 절대 키
   |	     |	         ▶각 테이블 당 하나의 primary key만 설정할 수 있다. 즉, [테이블당 0~1개]만 줄 수 있다.	
   |	     |	         ▶[기본키], [주키]라고도 한다.	
   |	    ㅜ
-------------------------
foreign key(FK) <중요, 핵심>
-------------------------
	▶primary 키에 존재하는 데이터만 삽입될 수 있다. (=primary 키를 참조하는 키다.)
	▶제약조건 위반 시 한 행의 모든 데이터가 입력되지 않음.
	▶각 [테이블 당 0개 이상(여러개)] 만들 수 있다.
	▶<주의>예외적으로 null 값 허용 가능. 즉, 예외적으로 데이터가 입력되지 않을 수 있음.
	▶table과 table간의 관계를 설정하는 키다.
	▶[참조키], [외래키], [관계키], [종속키] 라고도 한다.



<11> 시퀀스(Sequence) 가 무엇?

▶[고유 일련 번호]를 생성해서 제공하는 객체. 일종의 [일련 번호 생성기] 이다.
▶주로 하나의 테이블에서 PRIMARY KEY 로 지정된 컬럼명에 입력될 [일련 번호] 값을 생성한다.
▶(비유)은행에서 번호표 뽑는 기계와 동일한 기능을 가짐.
▶<주의> 개발 과정 도중 중간에 잘못 입력된 데이터로 인한 오류 발생 시 오류 발생으로 인한 번호 누락이 발생됨.

▶시퀀스 생성 SQL 구문

create sequence 시퀀스명
	start with 시작값
	increment by 증가값
	minvalue 최소값
	macvalue 최대값
<예>
create sequence sq_emp
	start with 999
	increment by -1
	minvalue 1
	macvalue 최대값

▶증가된 새 일련번호 얻는 SQL 구문
	시퀀스 명.nextval
▶마지막으로 이미 뽑혔던 일련번호 얻는 SQL 구문
	시퀀스 명.currval
▶시퀀스 삭제 SQL 구문
	drop sequence 시퀀스명;

<12>오라클 연습시 어떤 sw를 설치해야 한는가

<1>개발자 용 오라클 버전(=OracleXE ) 을 설치한다. system 계정의 비밀번호는 123 으로 한다.
<2>오라클 접속 툴의 한 종류인 Sqlgate 를 설치한다. 
<3>Sqlgate 를 실행하고 아래 사항을 입력한 후 접속을 한다, 
	▶IP            => localhost
	▶사용자        => system
	▶암호          => 설정암호
	▶SID(서비스명) => XE

<13> 시스템 계정으로 접속하니 쓸 데 없는 테이블이 많아 번거롭다.
시스템 계정과 동일한 권한을 가지는 새로운 계정을 만들려면?

① system 계정으로 접속한 후 코딩 창에서 아래 와 같은 명령으로 king 계정을 만들고 암호는 k123 으로 한다.
	create user king  identified by k123;
② 아래 와 같은 명령으로 king 계정에 system 계정과 동일한 권한을 부여한다.
	grant connect,resource,dba to king;
③ Sqlgate에서 king 계정으로 재 접속을 시도한 후 아래 사항을 입력한 후 접속을 한다, 
	●IP            => 127.0.0.1 또는 localhost
	●사용자        => king  
	●암호          => k123
	●SID(서비스명) => XE


<14>아래 고객 요구사항에 맞는 테이블을 만들면?

	1. 부서를 관리하고 싶다.
	2. 관리하고 싶은 부서 정보는 부서명, 부서 위치.
	3. 직원정보를 관리하고 싶다.
	4. 관리하고 싶은 직원 정보는 직원명, 직급, 입사일, 소속부서명, 연봉, 주민번호, 연봉등급, 직속상관명.
	5. 고객정보를 관리하고 싶다.
	6. 관리하고 싶은 고객 정보는 고객명, 전화번호, 주민번호, 담당직원명
	7. 연봉등급을 관리하고 싶다.
	8. 관리하고 싶은 연봉 정보는 연봉등급, 등급별 최소연봉, 등급별 최대연봉

SQL_02.sql 참조

-----------------------------------------------------------------------------------------------------------------------------------
<15 ~~ >(기)
<15> employee 테이블에서 모든 컬럼, 모든 행의 데이터를 검색하면?

-----------------------------------------------------------------------------------------------------------------------------
select emp_no, emp_name, dep_no, jikup, salary, hire_date, jumin_num, phone_num, mgr_emp_no from employee;
-----------------------------------------------------------------------------------------------------------------------------
select * from employee;  (* 사용시 create 구문 그대로 나옴)
-----------------------------------------------------------------------------------------------------------------------------
select 
	emp_no
	, emp_name
	, dep_no
	, jikup
	, salary
	, hire_date
	, jumin_num
	, phone_num
	, mgr_emp_no 
from 
	employee;



<16> employee 테이블에서 emp_no, emp_name, jikup, salary, hire_date 컬럼 데이터 검색하면?

-----------------------------------------------------------------------------------------------------------------------------
select emp_no, emp_name, jikup, salary, hire_date from employee;
-----------------------------------------------------------------------------------------------------------------------------
select 
	emp_no
	, emp_name
	, jikup
	, salary
	, hire_date 
from 
	employee;


<17>  employee 테이블에서 emp_no, emp_name, jikup, salary, hire_date 을 검색하면서 별칭(= alias)을 즉, 헤더를 
	사원번호, 직원명, 직급, 연봉, 입사일로 하고 연봉에 '만원'이란 문자를 붙여 검색하면?

-----------------------------------------------------------------------------------------------------------------------------
select emp_no, emp_name, jikup, salary, hire_date from employee;
-----------------------------------------------------------------------------------------------------------------------------
 
  select
	emp_no		          직원번호  ------------------  테이블에 들어갈 데이터가 아니므로 더블 코트를 사용
	, emp_name	          "직원 명"  ------------------ 가능하면 무조건 더블코트 사용
	, jikup		          "직급"    ------------------ as 생략 가능
	, salary||'만원'		 "연봉"    ------------------ 별칭에 공백 없을시 더블코드 생략 가능
	, hire_date 	      "입사일"  ------------------ 오라클에서 연결연산자는 +가 아니라 ||이다. 자바와 다름.
from
	employee;

-----------------------------------------------------------------------------------------------------------------------------
<18> employee 테이블에서 직원명, 직급, 연봉, 세금, 실수령액을 검색하면? (세금은 연봉의 12%)
-----------------------------------------------------------------------------------------------------------------------------

  select
	emp_name           	as "직원명"
	, jikup		            as "직급"
	, salary*0.12||'만원'		as "세금"		------- 계산하고자 하는 컬럼 * 숫자 || '문자'
	, salary*0.88||'만원'		as "실수령액"	
from
	employee;
-----------------------------------------------------------------------------------------------------------------------------
<19> employee 테이블에서 직급을 중복없이 검색?
-----------------------------------------------------------------------------------------------------------------------------

select distinct jikup from employee;

select distinct (jikup) from employee;

--

select unique (jikup) from employee;

-- 
-----------------------------------------------------------------------------------------------------------------------------
<20> employee 테이블에서 부서번호와 직급을 중복없이 검색?
-----------------------------------------------------------------------------------------------------------------------------

select distinct dep_no, jikup from employee;

-----------------------------------------------------------------------------------------------------------------------------
<21> employee 테이블에서 연봉이 3000만원 이상인 직원을 검색하면?
-----------------------------------------------------------------------------------------------------------------------------

select * from employee where salary >= 3000
                                --- <행을 골라내는 키워드>
-----------------------------------------------------------------------------------------------------------------------------
<22> employee 테이블에서 연봉 오름차순으로 검색하면?
-----------------------------------------------------------------------------------------------------------------------------

select * from employee order by salary  asc;
                                --- <행의 순서를 바꾸고자 할 때 키워드>
select * from employee order by salary; ---- asc 생략 가능

select * from employee order by 5 asc; ----order by 바로 뒤 column 명 대신 해당 column의 번호를 쳐도 가능

select * from employee order by 5;

-----------------------------------------------------------------------------------------------------------------------------
<23>  employee 테이블에서 연봉 내림차순으로 검색하면?
-----------------------------------------------------------------------------------------------------------------------------

select * from employee order by salary desc; ---- 내림차순. 생략 불가능

select * from employee order by 5 desc;

-----------------------------------------------------------------------------------------------------------------------------
<24> employee 테이블에서 부서번호 오름차순을 유지하면서 연봉을 내림차순으로 검색
-----------------------------------------------------------------------------------------------------------------------------

select * from employee order by dep_no asc, salary desc;

select * from employee order by dep_no, salary desc; -- asc생략은 가능하나 전체를 착각하게 만들 가능성 있음

-----------------------------------------------------------------------------------------------------------------------------
<25> employee 테이블에서 직급이 높은 순서 나열해서 검색하면?
-----------------------------------------------------------------------------------------------------------------------------

select * from employee order by jikup asc;
select * from employee order by jikup desc;
★둘 다 잘못된 예시
직급순서는 인간이 생각하는 기준과 오라클의 정렬기준과 다르기 때문
추후 조건문을 통해 정렬의 기준을 바꿔야 함

select * from employee order by decode( jikup , '사장' ,1, '부장' ,2, '과장' ,3, '대리' , 4), alary desc;
<명심> 고객의 요구사항을 보고 select문을 작성하는 것 또한 중요하지만,
	이미 작성된 select문을 보고 고객의 요구를 알아내는 것 역시 중요함.

-----------------------------------------------------------------------------------------------------------------------------
<26>employee 테이블에서 부장만 검색?
-----------------------------------------------------------------------------------------------------------------------------

select * from employee where jikup = '부장'

-----------------------------------------------------------------------------------------------------------------------------
<27> employee 테이블에서 20번 부서의 과장 검색?

select * from employee where dep_no = 20 and jikup = '과장'

-----------------------------------------------------------------------------------------------------------------------------
<28> employee 테이블에서 20번 부서 또는 과장 검색?
-----------------------------------------------------------------------------------------------------------------------------

select * from employee where dep_no = 20 or jikup = '과장'

-----------------------------------------------------------------------------------------------------------------------------
<29> employee 테이블에서 과장 중에 연봉 3400 이상 검색
-----------------------------------------------------------------------------------------------------------------------------

select * from employee where jikup = '과장' and salary >= 3400

-----------------------------------------------------------------------------------------------------------------------------
<30> employee 테이블에서 실수령액 4000만원 이상 받는 직원을 검색. 단, 세금은 12%라 가정.
-----------------------------------------------------------------------------------------------------------------------------

select * from employee where  salary*0.88>=4000;

----------------------------------------------------------------------------------------------------------------------------- 
<31> employee 테이블에서 세금을 제일 많이 내는 직원 순서로 나열하면서 부서번호가 내림차순이면서
사장이 아닌 직원을 검색?
-----------------------------------------------------------------------------------------------------------------------------

select * from employee where jikup != '사장' order by salary*0.12 desc, dep_no desc;

컬럼 명 != 대상('문자' 혹은 숫자 등) => 대상 제외 하고 검색

-----------------------------------------------------------------------------------------------------------------------------
<32> employee 테이블에서 20번 부서 중에서 연봉 2000~3000 사이 검색하면?
-----------------------------------------------------------------------------------------------------------------------------

select * from employee where dep_no=20 and salary>=2000 and salary<=3000;    2000<=salary<=3000 - 안됨

select * from employee where dep_no=20 and salary between 2000 and 3000; <참고>

-----------------------------------------------------------------------------------------------------------------------------
<33> employee 테이블에서 직속상관이 없는 직원 검색
-----------------------------------------------------------------------------------------------------------------------------

select * from employee where mgr_emp_no = null 

select * from employee where mgr_emp_no is null 

<주의> null값을 찾을 땐 = 을 쓰지 말것

-----------------------------------------------------------------------------------------------------------------------------
<34> employee 테이블에서 직속상관이 있는 직원 검색
-----------------------------------------------------------------------------------------------------------------------------

select * from employee where mgr_emp_no is not null

<35> 오라클 4대 천왕

내장함수		=> 미리 만들어진 단위 프로그램으로 호출하면 특정 작업을 하고 데이터를 리턴한다.
join		=> 서로 다른 테이블의 컬럼을 횡으로 붙이는 작업
subquery		=> SQL 구문 안의 select 문
group by		=> 통계 관련 작업

-----------------------------------------------------------------------------------------------------------------------------
<36> employee 테이블에서 [최소 연봉], [최대 연봉], [평균 연봉], [연봉 총합], [총 인원수]를 검색해서 출력
-----------------------------------------------------------------------------------------------------------------------------

select
	min( slalry )	as "최소 연봉"  -- salary 컬럼에서 최소값을 리턴
	,max( salary )	as "최대 연봉"  -- salary 컬럼에서 최대값을 리턴
	,avg( salary )	as "평균 연봉"  -- salary 컬럼에서 평균값을 리턴 <조심> avg 사용 시 null 있으면 더할 때 빠지고, 나누는 개수에서도 빠진다
	,sum( salary )	as "연봉 총합"  -- salary 컬럼에서 총합을 리턴
	,count( * )	as "총 인원수"  -- count( * )는 총행의 개수 --
from
	employee;

-----------------------------------------------------------------------------------------------------------------------------
★min, max, avg, sum, count 함수들을 [그룹함수] 또는 [통합함수]라고 부르기도 한다.
그룹지어서 연산을 하는 함수이기 때문
그룹함수들은 주로 group by 와 같이 많이 사용된다.
★min, max, avg, sum, count 함수들은 null값 제외하고 계산한다.
count(컬럼명) => 컬럼안의 null이 아닌 데이터의 개수를 리턴한다.
count(*)	      => 행의 개수를 리턴한다.

ex, select count (cus_no) from customer;
-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------
<37> 아래 SQL 구문은 무슨 문제의 답인가?
select count (emp_no) from customer;
	==>
emp_no 컬럼안의 담당 직원의 직원번호이므로 직원번호의 개수는 결국 담당 직원이 있는 고객의 명수가 된다.
	==>중복을 제거한다면==>
-----------------------------------------------------------------------------------------------------------------------------

-----------------------------------------------------------------------------------------------------------------------------
<38> 고객을 담당하고 있는 직원 명수
-----------------------------------------------------------------------------------------------------------------------------

select count(distinct emp_no) from customer;

distinct 컬럼명 => 컬럼 안의 데이터 중 중복을 제거

-----------------------------------------------------------------------------------------------------------------------------
<39> 직속상관이 있는 직원의 명수
-----------------------------------------------------------------------------------------------------------------------------

select count(mgr_emp_no) from employee;

<주의>mgr_emp_no 컬럼 안의 데이터가 뭔지 뭔저 파악해야한다. 바로 직속 상관의 직원번호이다.

-----------------------------------------------------------------------------------------------------------------------------
<39-2>부하직원이 있는 직원의 명수?
-----------------------------------------------------------------------------------------------------------------------------

select count(distinct mgr_emp_no) from employee;

distinct 컬럼명 => 컬럼 안의 데이터의 중복을 제거
<주의> count에는 업무적 특징이 숨어 있어 조심히 날려야한다.
		  ||
고객의 다양하고 복잡한 요구사항

-----------------------------------------------------------------------------------------------------------------------------
<40> employee 테이블에서 [직원번호], [직원명], [생일월-생일일]를 검색해서 출력
-----------------------------------------------------------------------------------------------------------------------------

	select
		emp_no						"직원번호"
		, emp_name					"직원명"
		, substr(jumin_num,3,2)||'-'||substr(jumin_num,5,2)	"생일월일"
	from
		employee;

 *****substr(컬럼명, 복사할 시작순서번호, 복사할개수) => 시작순서번호 부터 복사할개수 만큼 복사해서 리턴하기
						엄청난 사용빈도를 자랑한다.

오라클은 인덱스 번호가 없다

★ substr(컬럼명, 카피해올 데이터의 시작번호, 갯수)

<41> customer 테이블에서 모든 컬럼, 모든 행을 검색해서 출력. 
단, 주민번호는 901225-2****** 형태로 출력할것

select
		cus_no						
		, cus_name					
		, tel_num
		, substr(jumin_num,1,6)||'-'||substr(jumin_num,7,1)||'******'
		, emp_no	
	from
		customer;

<주의> '모든 행' 이란 말이 나오면 where절이 없다.

*****substr(컬럼명, 복사할 시작순서번호, 복사할개수) => 시작순서번호 부터 복사할개수 만큼 복사해서 리턴하기
						엄청난 사용빈도를 자랑한다.

||  ==> 좌우의 문자열을 붙이는 연산자, 즉 연결 연산자이다.
<주의> 오라클에서 + 는 연결연산자가 아니라 사칙연산자이다.

'tom'||'my'

'tom'||123  --> 'tom'||'123' -->  'tom123' 

<42> customer 테이블에서 고객번호, 고객명, 담당직원번호 를 출력하면?
단, 담당직원번호가 없으면 null 출력하지 말고 '없음' 으로 표시
<자동 형 변환 활용>
select 
	cus-no
	, cus_name
	, nvl(emp_no||'','없음')
from
	customer;
----------------------------------------------------------------------
<정석>
select
	cus_no
	, cus_name
	, nvl(to_char(emp_no),'없음')
from
	customer;
---------------------------------------------------------------------
★nvl( 컬럼명, null값일때 대체데이터)

 -- null값 처리 함수. 컬럼명 안의 데이터가 null이 아니면 그냥 리턴하고,
  null값 이면 null값대체데이터를 리턴하는 [null처리 내장함수]이다.
 
<43> customer 테이블에서 고객번호, 고객명, 담당직원존재여부 를 출력하면?
단, 직원번호가 있으면 '있음', 없으면 '없음'으로 표시

select 
	cus-no
	, cus_name
	, nvl2(emp_no, '있음' , '없음')
from
	customer;

★nvl2( 컬럼명, null값 아닐때 대체 데이터, null값 일때 대체 데이터 ) 

-- 컬럼명 안의 데이터가 null이 아니면 null값 아닐때 대체데이터로 출력하고
null이면 null값일때 대체데이터를 리턴하는 [null 처리 내장함수] 이다. 
	

<44> employee 테이블에서 직원번호, 직원명, 직급, <성별>을 출력하면...

select
	emp_no
	, emp_name
	, jikup
	, case 
		substr(jumin_num,7,1)
		when '1' then '남'
		when '3' then '남' 
		when '2' then '여' 
		when '4' then '여' 
	end
from
	employee
----------------------------------------------------------------------------------------------------------------------------------
select
	emp_no
	, emp_name
	, jikup
	, case 
		substr(jumin_num,7,1) 
		when '1' then '남' 
		when '3' then '남' 
		else '여' 
	end
from
	employee
----------------------------------------------------------------------------------------------------------------------------------
select
	emp_no
	, emp_name
	, jikup
	, case 
		when substr(jumin_num,7,1)='1' then '남'
		when substr(jumin_num,7,1)='3' then '남'
		else '여'
	end
from
	employee

----------------------------------------------------------------------------------------------------------------------------------
select
	emp_no
	, emp_name
	, jikup
	, decode(
		substr(jumin_num,7,1),'1','남','3','남','여')
from
	employee
----------------------------------------------------------------------------------------------------------
case ~ end 구문 패턴 설명

<패턴1>
●case 컬럼명 
	when 데이터1 then 리턴값1
	when 데이터2 then 리턴값2
	~
	else 리턴값n
end

컬럼명 안의 데이터가 데이터1과 같으면 리턴값1을 리턴
컬럼명 안의 데이터가 데이터2과 같으면 리턴값2을 리턴
~
그 외에는 리턴값n을 리턴하기

<패턴2>
●case 컬럼명 
	when 컬럼명 = 데이터1 then 리턴값1
	when 컬럼명 = 데이터2 then 리턴값2
	~
	else 리턴값n
end


컬럼명 안의 데이터가 데이터1과 같으면 리턴값1을 리턴
컬럼명 안의 데이터가 데이터2과 같으면 리턴값2을 리턴
~
그 외에는 리턴값n을 리턴하기

패턴2 에서 = 대신에 필요에 따라 >=, >, <, <=, != 등의 비교연산자도 사용할 수 있다.
필요에 따라 else 리턴값n은 생략될 수 있다.

decode(~) 구문의 패턴 설명

decode(
	컬럼명
	, 비교데이터1, 리턴값1
	, 비교데이터2, 리턴값2
	, ~
	, 리턴값n
)


컬럼명 안의 데이터가 데이터1과 같으면 리턴값1을 리턴
컬럼명 안의 데이터가 데이터2과 같으면 리턴값2을 리턴
~
그 외에는 리턴값n을 리턴하기


필요에 따라 그외 경우 리턴값n은 생략될 수 있다.

decode 단점 =
 오라클에서밖에 못쓰는 오라클 전용함수. case ~ end 구문은 모든 DB에서 사용가능하다.
 '같다'라는 조건에서만 사용 가능
-----------------------------------------------------------------------------------------------------------
각 자리수마다 무엇이 있는지 알기 어렵기 때문에 사용에 주의해야

case = 모든 데이터베이스에서 사용 가능			

case substr(컬럼명, 카피해올 데이터의 시작번호, 갯수) when A then B (else) end


<45> employee 테이블에서 직원번호, 직원명, 직급, <출생년도>를 출력


select
	emp_no
	, emp_name
	, jikup
	, case
		when substr( jumin_num,7,1)='1'then'19'||substr(jumin_num,1,2)
		when substr( jumin_num,7,1)='2'then'19'||substr(jumin_num,1,2)
		when substr( jumin_num,7,1)='3'then'20'||substr(jumin_num,1,2)
		when substr( jumin_num,7,1)='4'then'20'||substr(jumin_num,1,2)
	end
from
	employee;
-------------------------->>>
select
	emp_no
	, emp_name
	, jikup
	, case
		when substr( jumin_num,7,1)='1'then'19'
		when substr( jumin_num,7,1)='2'then'19'
		else '20'
		end || substr(jumin_num,1,2)
from
	employee;
--------------------------->>>
select
	emp_no
	, emp_name
	, jikup
	, decode (substr(jumin_num,7,1),'1','19'||substr(jumin_num,1,2),'2','19'||substr(jumin_num,1,2),'20'||substr(jumin_num,1,2))
	, decode (substr(jumin_num,7,1), '1', '19', '2', '19', '20') || substr(jumin_num,1,2) <= 실 정답	
from
	employee;

<46> employee 테이블에서 직원번호, 직원명, 직급, <출생년대(4자리)>를 출력

select
	emp_no
	, emp_name
	, jikup
	, case
		when substr( jumin_num,7,1)='1'then'19'
		when substr( jumin_num,7,1)='2'then'19'
		else '20'
		end || substr(jumin_num,1,1)||'0년대'
from
	employee;

<47> employee 테이블에서 나이순으로 출력하면? 연장자가 먼저 나오도록.

select * from employee order by                                  <-----------정렬 기준으로
	case
	when substr( jumin_num,7,1)='1'then'19'
	when substr( jumin_num,7,1)='2'then'19'
	else '20'
	end || substr(jumin_num,1,6)
	asc;

<주의>
select * from employee order by jumin_num asc; - 오류(2000년생이 먼저 나오기 때문. 2000년생은 주민번호가 00으로 시작.

order by 뒤는 정렬 기준 컬럼이 나온다. 정렬 기준 컬럼을 case가 끌어 안아서 다른 형태로 바꾼 것이다. 

order by 구문의 패턴

order by 컬럼명 | 컬럼순서번호 | 컬럼알리아스 [asc] | desc

<48> employee 테이블에서 직급순서대로 정렬하여 모든 컬럼을 보이면?

select * from employee order by 
	case jikup 
		when '사장' then 1
		when '부장' then 2
		when '과장' then 3
		when '대리' then 4
		when '주임' then 5 else 6
	end
	asc;

select * from employee order by 
	decode( jikup, '사장', 1, '부장', 2, '과장', 3, '대리', 4, '주임', 5, 6 ) asc; 
			숫자 반대 상황의 경우 다르게 해석할 수 있으니 조심해서


order by 뒤는 정렬 기준 컬럼이 나온다. 정렬 기준 컬럼을 case가 끌어 안아서 다른 형태로 바꾼 것이다. 

정렬 시 사장은 1로 보고, 부장은 2로 보고, 과장은 3으로 보고, 대리는 4로 보고, 주임은 5로 보고 기타는 6으로 보고
오름차순으로 정렬. 즉, 직급을 정수로 바꿔서 정렬을 한 것이다.

＠asc를 desc로 바꾸면 직급이 낮은 사람이 먼저 나온다

<49> employee 테이블에서 직원번호, 직원명, 입사일(년-월-일(요일) 분기 시분초) 검색

select 
	emp_no
	, emp_name
	, to_char(hire_date,'YYYY-MM-DD(D(A생략가능)Y) Q<분기> AM<오전. 오후는 PM 또는 HH24> < HH:MI:SS<시분초>' 
	, 'nls_date_language = Korean') 
from 
	employee;

select 
	emp_no
	, emp_name
	, to_char(hire_date,'YYYY-MM-DD Q AM HH:MI:SS' 
	, 'nls_date_language = Korean') 
from 
	employee;


-------------------------------------------------------------------------------------------
to_char( 날짜 또는 숫자 컬럼, '출력시 원하는 문자패턴' )

문자데이터가 아닌 데이터를 작성자가 원하는 데이터로 전환할 때 필요.

지정한 날짜 또는 숫자를 원하는 출력문자패턴 으로 바꾸어 주는 변환함수의 일종
주로 출력할기 위해 사용.

YYYY 	=> 년도 4자리
MM  	=> 월 2자리
DD   	=> 일 2자리
AM HH	=> 오전 | 오후 1~12 사이의 시간
HH24 	=> 0~23 사이의 시간
MI	=> 0~59 사이의 분
SI	=> 0~59 사이의 초
DAY	=> 영문 요일 풀네임
DY 	=> 영문 요일 요약
Q 	=> 1~4 사이의 분기

to_char(hire_date, 'YYYY-MM-DD')
hire_date 컬럼 안의 데이터를 년-월-일 패턴의 문자열로 바꾸어 리턴하라


<49-2> employee 테이블에서 직원번호, 직원명, 입사일(x년-x월-x일(요일) x분기 x시x분x초 ) 검색하라
1999년-12월-25일(화) 4분기 11시 10분 22초

select
	emp_no
	, emp_name
	, to_char(hire_date,'YYYY')||'년'
		|| to_char(hire_date, 'MM')||'월'
		|| to_char(hire_date, 'DD') ||'일'
		|| to_char(hire_date, '(DY)', 'nls_date_language = Korean')
		|| to_char(hire_date, 'Q' ) || '분기' 
		|| to_char(hire_date, 'AM HH' ) || '시'
		|| to_char(hire_date, ' :MI' ) || '분'
		|| to_char(hire_date, ' :SS' ) || '초'
from
	employee;

select 
	emp_no
	, emp_name
	, to_char(hire_date, 'YYYY"년"MM"월"DD"일"(DY) Q"분기" AM HH"시"MI"분"SS"초" ' , 'NLS_DATE_LANGUAGE = KOREAN' )
from 
	employee;


<50> employee 테이블에서 직원번호, 직원명, 나이 검색

select 
	emp_no
	, emp_name
	, to_number(to_char(sysdate, 'YYYY')) 
- to_number( 
	case
	substr( jumin_num,7,1) when '1' then'19' when '2' then '19' else '20' end 
	|| substr(jumin_num,1,2)) 
	+ 1||'세'
from 
	employee;
--------------------------------------------------------------------------------------------------------------------

select 
	emp_no
	, emp_name
	, to_number( to_char(sysdate, 'YYYY') )
	-
	to_number(
		(case substr( jumin_num,7,1) when '1' then'19' when '2' then '19' else '20' end 
		|| substr(jumin_num,1,2) 
	) + 1 || '세'
from 
	employee;

----------------------------------------------------------------------------------------------------------------------
to_number(숫자문자내장된컬럼명) => 컬럼명 안의 숫자 물자를 숫자로 변경하는 변환함수




<51> employee 테이블에서 직원번호, 직원명, 근무년차를 검색 출력

select 
	emp_no
	, emp_name
	, 오늘날짜에서 입사일 날짜까지의 차이를 일수로 구한 다음 365로 나눈 후 소수 첫째 자리에서 무조건 올림
from employee;
----------------------------------------------------------------------------------------------------------------------------

select 
	emp_no					"직원번호"
	, emp_name				"직원명"
	, ceil( (sysdate-hire_date)/365 )||'년차'		"근무년차"
from employee;
----------------------------------------------------------------------------------------------------------------------------
★오라클은 날짜-날짜 의 결과값은 날짜차이만큼의 일수이다
ceil(~)  	=> 소수 첫째 자리에서 무조건 올림해서 리턴하는 수학 함수의 일종이다. (숫자 자료형의 칼럼을 끌어안고)
floor(~) 	=> 소수 첫째 자리에서 무조건 내림해서 리턴하는 수학 함수의 일종이다.

<참고> 오라클은 날짜 데이터에서 날짜 데이터를 빼면 그 차이만큼을 일 수로 리턴하는 특징 있음.(전용 함수가 없기 때문)
	더하는 건 아예 없음.

<52> employee 테이블에서 직원번호, 직원명, 연령대를 검색해서 출력하면

select 
	emp_no					
	, emp_name				
	,
	floor(	(to_number( to_char(sysdate, 'YYYY')) 
	- to_number( case substr( jumin_num,7,1) when '1' then'19' when '2' then '19' else '20' end 
	|| substr(jumin_num,1,2)
	)+ 1
	)*0.1
	)||'0대'
		
from employee;

<53>  employee 테이블에서 직원번호, 직원명, 100일잔치 날짜를 검색해서 출력하면

select 
	emp_no					
	, emp_name				
	, to_char(
		to_date(
			case when substr ( jumin_num,7,1 ) in('1', '2' ) then '19' else '20' end
				 ||substr(jumin_num,1,6)
				, 'YYYYMMDD' 
				)+100
				, 'YYYY-MM-DD'
		)	
from 
	employee;


날짜 + 정수 	==> 날짜에 정수만큼의 일수를 더한 날짜를 리턴
날짜 - 정수 	==> 날짜에 정수만큼의 일수를 뺀 날짜 리턴
날짜1-날짜2 	==> 날짜1과 날짜2 까지의 차이를 일수로 리턴. 일수 양수가 날짜1이 날짜2보다 큰 것(음수 반대)
날짜1+날짜2	==> 없음


순서대로 1. 100을 더하기 위해 날짜로 바꾸고 2. 'YYYY-MM-DD'화 하기 위해 문자로 바꿈

<54> 개강일이 2021년 5월 12일 이고 종강일이 2021년 11월 10일 이다. 몇일 동안 학원 생활

select
	to_date('20211110', 'YYYYMMDD')
	-
	to_date('20210512', 'YYYYMMDD')
from
	dual;

날짜끼리 빼는 함수 공식
to_date('큰 날짜', 'YYYYMMDD') - to_date('작은 날짜', 'YYYYMMDD')


dual(가상 혹은 더미 테이블) - 존재되어 있는 테이블이 있지 않는 경우


<참고>
~~ where dep_no = 10 or dep_no = 20;
~~ where dep_no in(10,20);


<참고>오라클은 날짜에다가 정수를 더하거나 빼면 정수 만큼의 날짜가 더하거나 빼져 날짜 취급된다(전용 함수 없음)

<55> employee 테이블에서 직원번호, 직원명, 현재나이, 입사일 당시나이를 검색해서 출력

현재 나이 구하는 공식 : 현재날짜(sysdate)에서 주민번호를 빼는 방식을 통해 구하는 것이 가능

select
	emp_no
	, emp_name
	, to_number(to_char(sysdate, 'YYYY'))
	- to_number(
	case substr( jumin_num,7,1) when '1' then'19' when '2' then '19' else '20' end
	|| substr(jumin_num,1,2))
	+ 1||'세'
	, to_number(to_char(hire_date, 'YYYY'))
	- to_number(
	case substr( jumin_num,7,1) when '1' then'19' when '2' then '19' else '20' end
	|| substr(jumin_num,1,2))
	+ 1||'세'

 decode (substr(jumin_num,7,1), '1', '19', '2', '19', '20') || substr(jumin_num,1,2) -- 출생년도

from
employee;

<56> employee 테이블에서 직원번호, 직원명, 주민번호, 다가올생일날( 년-월-일 ), 생일까지 남은 일수를 검색하면?

select
	emp_no		"직원번호"
	, emp_name	"직원명"
	, jumin_num	"주민번호"
	, case when 
	to_date( to_char( sysdate,'YYYY') || substr(jumin_num,3,4), 'YYYYMMDD')  --- 올해 생일
	- sysdate				      			       --- 지금 이시각 날짜		
	>=0
	then 
	to_char( to_date( to_char(sysdate,'YYYY') || substr(jumin_num,3,4), 'YYYYMMDD'), 'YYYYMMDD' ) 
	else
	to_char( to_date( to_number(to_char(sysdate,'YYYY'))+1 || substr(jumin_num,3,4), 'YYYYMMDD'), 'YYYYMMDD (dy)' ) 	
	end  "다가올 생일날"
	, case when 
	to_date( to_number( to_char( sysdate,'YYYY') || substr(jumin_num,3,4), 'YYYYMMDD')  
	- sysdate				      			     		
	>=0
	then 
	to_date( to_number( to_char( sysdate,'YYYY') || substr(jumin_num,3,4), 'YYYYMMDD') 
	- sysdate
	else
	to_date( extract( year from sysdate,'YYYY')+1 || substr(jumin_num,3,4), 'YYYYMMDD')
	- sysdate	
	end  "생일까지 남은 일수"
from
	employee
order by "생일까지 남은 일수" asc;

생일까지 남은 일수 계산방법

	 만약 올해생일날짜-지금날짜 값이 양수면 생일이 안 지났으므로 올해생일날짜-지금날짜 면 된다.
		
	 만약 올해생일날짜-지금날짜 값이 음수면 생일이 지났으므로 내년생일날짜-지금날짜 면 된다.
	
<56> employee 테이블에서 직원번호, 직원명, 직급, 연봉(xxx,xxx,xxx만원) 를 검색하면

select
	emp_no						"직원번호"
	, emp_name					"직원명"
	, jikup						"직급"
	, to_char( salary, '999,999,999' ) || '만원'		"연봉"
from
	employee
--------------------------------------------------------------------------
 to_char( salary, '999,999,999' )  ==> salary 컬럼안의 숫자를 3자리마다 끊어서 , 를 삽입해서 문자로 리턴하기 
				만약 각 9 자리에 대응하는 숫자 없으면 화면에 출력이 안된다.
--------------------------------------------------------------------------
 to_char( salary, '099,999,999' )  ==> salary 컬럼안의 숫자를 3자리마다 끊어서 , 를 삽입해서 문자로 리턴하기 
				맨앞에 0이 있으면 그자리가 비면 0 이 대체된다. 따라서 나머지도 9이어도 다
				0으로 대체가 된다.

<57> employee 테이블에서 수요일에 태어난 직원을 검색

select * from employee
where to_char(
		to_date(
			decode( substr( jumin_num,7,1), '1' , '19' , '2' , '19' , '20' ) || substr( jumin_num,1,6 ), 'YYYYMMDD' )
		,'DAY'
		,'nls_date_language = Korean') = '수요일'

select * from employee
where to_char(
		to_date(
			decode( substr( jumin_num,7,1), '1' , '19' , '2' , '19' , '20' ) || substr( jumin_num,1,6 ), 'YYYYMMDD' )
		,'DY'
		,'nls_date_language = Korean') = '수'

select * from employee
where to_char(
		to_date(
			decode( substr( jumin_num,7,1), '1' , '19' , '2' , '19' , '20' ) || substr( jumin_num,1,6 ), 'YYYYMMDD' )
		,'D'
		) = '4'


----------------------------------------------------------------------------------------------------------------------------
<57> 오라클의 자주 사용되는 숫자함수 예를 보여주시오  ★★★★★★★★★

abs( n ) - 숫자 n의 절대값을 반환

floor( n ) - 숫자 n이 정수면 그대로 반환하고, 실수면 실수보다 작으면서 제일 가까운 정수를 반환.
	  좌표계에서 쿵 찍어서 왼쪽 정수값

ceil( n ) - 숫자 n이 정수면 그대로 반환하고, 실수면 실수보다 크면서 제일 가까운 정수를 반환.
	좌표계에서 쿵 찍어서 오른쪽 정수값

round( n, m ) - 숫자 n 에서 소수 m+1 자리에서 반올림한 수 리턴

trunc( n, m ) - 숫자 n 에서 소수 m+1 자리부터 버림

sign( n ) - n>0 이면 1, n<0 이면 -1, n=0 면 0을 반환

mod( n, m ) - n/m 후 나머지 값을 반환

power( n, m ) - n의 m 승을 반환.


<58> 오라클의 자주 사용되는 문자 함수 예를 보여주시오

chr( n ) - 정수 n을 ascii( 아스키 ) 문자기호로 리턴한다

upper( s ) - 문자열 s을 대문자로 변환시켜 리턴한다

lower( s ) - 문자열 s을 소문자로 변환시켜 리턴한다

length( s ) - 문자열 s의 길이를 리턴한다. (0 이상의 정수)

substr( s, n1, n2 ) 	- 문자열 s에서 n1 번째 자리부터 n2개 까지의 문자를 리턴한다.
	           	- n2 생략 시 마지막 까지 문자를 리턴한다.
		- n1이 0일 경우 1로 바꿔 실행된다.
		- 자리수는 n1>0 경우 왼쪽부터, n1<0 경우 오른쪽부터 샘한다.
---------------------------------------------------------------------------------------------
		select substr( 'you are not alone', 9, 3 ) from dual;
		select substr( 'you are not alone', 0, 5 ) from dual;
		select substr( 'you are not alone', 5 ) from dual;
		select substr( 'you are not alone', -5, 2 ) from dual;
		select substr( 'you are not alone', 5, 0 ) from dual;
trim( s ) - 문자열 s1의 맨좌우측의 공백을 제거하여 리턴한다.
	제거 후 또 있으면 계속 제거 후 리턴한다.

<58> employee 테이블에서 70년대생 남자 직원 검색

select * from employee
	where
		substr( jumin_num, 1, 1) = '7'
		and	
		substr( jumin_num, 7, 1) = '1'

<59> employee 테이블에서 1960년대, 1970년대 출생자중 남자만 검색

select * from employee
	where
		(substr( jumin_num, 1, 1) = '6' or substr( jumin_num, 1, 1) = '7')
		and	
		(substr( jumin_num, 7, 1) = '1' or substr( jumin_num, 7, 1) = '3')		

둥근 괄호 없을 시 and가 or보다 먼저 사용되어진다 (순서 주의)

<60> employee 테이블에서 올해 근무한 직원이 먼저 나오게 검색

select * from employee order by 
	to_number(hire_date - sysdate) desc;

select * from employee order by 
	(sysdate - hire_date) desc;
---------------------------------------------------------------------------------------------------------------------
sysdate - hire_date => 지금날짜 - 입사일.		날짜에서 날짜를 빼면 차이만큼 일수를 리턴<중요>

<61> employee 테이블에서 직원번호, 직원명, 근무일수, 근무개월수, 입사후5개월후날짜(년-월-일), 입사한달의 마지막날짜(년-월-일)
입사한날짜기준돌아오는일요일날짜(년-월-일) 검색
단, 근무일수는 소수 2자리에서 반올림할것

select
	emp_no							"직원번호"
	, emp_name						"직원명"
	, trunc(sysdate-hire_date,1)					"근무일수"
	, months_between(sysdate, hire_date)				"근무개월수"
	, to_char(add_months(hire_date, 5), 'YYYY-MM-DD' )		"입사후5개월후날짜"
	, to_char(last_day(hire_date), 'YYYY-MM-DD' )			"입사한달의마지막날짜"
	, to_char(next_day(hire_date,1) 'YYYY-MM-DD' )			"입사한날짜기준돌아오는일요일날짜"
from
	employee				날짜에서 정수를 더하거나 빼면 날짜가 리턴<중요>

<62> employee 테이블에서 직급이 과장인 직원을 검색

select * from employee where jikup = '과장'

<63> employee 테이블에서 직급이 과장이 아닌 직원을 검색

select * from employee where jikup != '과장'
select * from employee where jikup <> '과장'

<64>  employee 테이블에서 부서번호가 10번이고 직급이 과장인 직원

select * from employee where jikup = '과장' and dep_no = 10

<65>  employee 테이블에서 직급이 과장 또는 부장인 직원

select * from employee where jikup = '과장' or jikup = '부장'

select * from employee where jikup in( '과장', '부장' );

<중요> 컬럼명 in ( '~~~' , '~~~' )--- =과 or의 의미를 같이 가짐

select * from employee where jikup = any('과장', '부장');   ----- any 사용 시 왼쪽에 반드시 = 넣어야 함

<66>  employee 테이블에서 10번, 20번 부서 중 직급이 과장인 직원

select * from employee where (dep_no=10 or dep_no=20) and jikup = '과장';

select * from employee where dep_no in (10,20) and jikup = '과장';

<67> customer 테이블에서 담당직원이 없는 고객을 검색

select * from customer where emp_no is null;

<68> customer 테이블에서 담당직원이 있는 고객을 검색

select * from customer where emp_no is not null;

<69>  customer 테이블에서 담당직원 번호가 9번이 아닌 고객

select * from customer where emp_no != 9 or emp_no is null;

<70> employee 테이블에서 연봉이 3000~4000만원 사이인 직원 검색

select * from employee where salary >= 3000 and salary <= 4000;

select * from employee where salary between 3000 and 4000;

<71> employee 테이블에서 연봉이 3000만원 이상 4000만원 미만 사이인 직원

select * from employee where salary >= 3000 and salary < 4000;

select * from employee where salary between 3000 and 4000 and salary != 4000;

between 왼쪽에 컬럼명!

<72> employee 테이블에서 연봉을 5% 인상했다고 가정하고 3000 이상인 직원을 검색

select * from employee where salary * 1.05 >= 3000;

<73> employee 테이블에서 입사일이 '1995-1-1' 이상인 직원을 검색

select * from employee where hire_date >= to_date('1995-1-1', 'YYYY-MM-DD');

<74> employee 테이블에서 입사일이 1990년~1999년 사이인 직원 검색

select * from employee where hire_date >= to_date('1990-1-1', 'YYYY-MM-DD')
			   and
			   hire_date < to_date('2000-1-1', 'YYYY-MM-DD');
----------------------------------------------------------------------------------------
select * from employee where
		to_number( to_char(hire_date, 'YYYY') ) between 1990 and 1999;

<75> employee 테이블에서 부서번호가 10번 또는 30번인 직원 중에 연봉이 3000미만이고 입사일이 '1996-01-01' 미만 직원 검색

select * from employee where
		dep_no in(10, 30) -- dep_no = any(10, 30) -- (dep_no = 10 or dep_no = 30)
			and salary < 3000
				and hire_date<to_date('1996-01-01', 'YYYY-MM-DD');

<76> employee 테이블에서 성이 '김'씨인 직원 검색

select * from employee where substr(emp_name, 1, 1) = '김';
select * from employee where emp_name like '김%'; ----'김' 이후에는 무엇이든 자유롭게 올 수 있게 함
---------------------------------------------------------------------------------------------------------------
where 컬럼명 like '패턴문자열' => 컬럼명 안의 데이터가 패턴문자열을 갖고 있으면 그 행을 검색하라
emp_name like '김%' => 김이 첫 글자고 두번째는 무엇이 와도 좋고 길이에 제한 없는 문자 패턴을 골라라
		   => 문자패턴 안의 %는 무엇이 와도 좋고 길이에 제한없음의 의미이다.
		   => like 왼 쪽이 컬럼명

<77> employee 테이블에서 성이 황씨인 직원 검색

select * from employee where 
	substr(emp_name, 1, 1) = '황' and substr(emp_name, 1, 2) != '황보';
---------------------------------------------------------------------------------------------------
select * from employee where 
	emp_name like '황%' and emp_name not like '황보%'

<78> employee 테이블에서 이름이 2자인 직원을 검색

select * from employee where length(emp_name)=2;
----------------------------------------------------------------------------------------------------
length(컬럼명) => 컬럼명 안의 문자데이터의 길이를 0이상의 정수로 리턴해주는 함수

<79> employee 테이블에서 이름이 김으로 끝나는 직원 검색

elect * from employee where emp_name like '%김';
elect * from employee where substr(emp_name,length(emp_name),1)='김'

<80> employee 테이블에서 성이 김씨이고 3글자인 직원을 검색

select * from employee where substr(emp_name, 1, 1) = '김' and length(emp_name)=3

select * from employee where emp_name like '김%' and length(emp_name)=3

select * from employee where emp_name like '김__';

<81> employee 테이블에서 이름에 김이란 문자를 가진 직원 검색

select * from employee where emp_name like '%김%'; ---<주의> 중간에 '김'이 있다는 게 아니라 어디에든 '김'이 있다는 뜻이다.

<82> employee 테이블에서 성이 김씨가 아닌 직원

select * from employee where emp_name not like '김%'

<83>  employee 테이블에서 이름 중간에만 김이 들어간 직원

select * from employee where emp_name like '%김%'
			   and emp_name not like '김%'
			   and emp_name not like '%김'

<84> employee 테이블에서 여자 직원을 검색

select * from employee where substr(jumin_num,7,1) = '2' or substr(jumin_num,7,1) = '4';

select * from employee where substr(jumin_num,7,1) in ('2', '4');

select * from employee where
	jumin_num like '______2%' or jumin_num like '______4%'; ---<주의> 언더바 시 언더바 숫자 개수를 정확히 해야 한다.

select * from employee where
	jumin_num not like '______1%' and jumin_num not like '______3%';

만약 주민번호 중간에 - 가 있다면 아래 처럼해도 된다.

select * from employee where
	jumin_num like '%-2%' or jumin_num like '%-4%'

<85> employee 테이블에서 1960년대, 1970년대 출생자 중 남자만 검색하라
---------------------------------------------------------------------------------------------------------------------
select * from employee where 
		(substr(jumin_num,1,1)='6' or substr(jumin_num,1,1)='7') and substr(jumin_num,7,1)='1';
---------------------------------------------------------------------------------------------------------------------
select * from employee where 
		substr(jumin_num,1,1) in (6,7) and substr(jumin_num,7,1)='1';
---------------------------------------------------------------------------------------------------------------------
select * from employee where
	jumin_num like '6_____1%' or jumin_num like '7_____1%'; 
---------------------------------------------------------------------------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<86> 오라클에서 자주 사용되는 숫자함수 예를 보여주세요.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
--------------------------------------
★ 06.21 스타트

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<87> join(조인)이란
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

2개 이상의 테이블로부터 컬럼을 복사해서 횡으로 붙이는 작업을 말한다.

▶예 > 아래 직원번호와 직원명은 employee 테이블 소속이고, 소속부서명은 dept 테이블 소속이다.

----------------------------------------------------
직원번호		직원명		소속부서명
   1 		홍길동		  총무부



■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<88> join(조인)의 종류
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	------------------------------------------------------
	inner join
	------------------------------------------------------
		▶ 조인 조건에 맞는 행만 포함하는 조인. 대부분의 조인이 이것( 내부 조인이라고도 함)
	------------------------------------------------------
	outer join
	------------------------------------------------------
		▶ 조인 조건에 만족하지 못한 행도 출력하는 조인이다. 상대적으로 어렵.
	------------------------------------------------------
	self join	
	------------------------------------------------------
		▶ 1개의 테이블을 2개 이상으로 보고 하는 조인. 상대적으로 어렵.
	------------------------------------------------------
	cross join 
	------------------------------------------------------
		▶ 2개 이상의 테이블에서 각각의 행이 모두 연결되는 조인이다. 연결 조건이 생략된다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<89> join(조인)에는 ANSI 조인형식과 오라클 조인이 있다는데 그 정의는?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	ANSI 조인--
		모든 DB 업체에서 공용으로 사용되는 조인
	오라클 조인--
		오라클에서만 사용되는 조인

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<90> 직원번호, 직원명, 소속부서명, 
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

<주의>직원번호의 직원명은 employee 테이블 소속이고, 소속부서명은 dept테이블 소속이다
<주의>단순한 select가 아닌 2개 테이블로부터 <연관성 있는 컬럼>을 복사해서 
횡으로 붙이는 작업 즉 조인이 필요 - 유저가 보기 편하게 - 핵심

<오라클 inner조인>테이블에 별칭 / 별칭 주지 않고

select
	employee.emp_no			"직원번호"
	,employee.emp_name		"직원명"
	,dept.dep_name			"소속부서명"
from
	employee, dept 
where
	employee.dep_no=dept.dep_no

select
	e.emp_no			"직원번호"
	,e.emp_name			"직원명"
	,d.dep_name			"소속부서명"
from (from 뒤에 테이블 )
	employee e, dept d
where ( 오라클 조인에서의 where은 횡으로 붙이는 작업에서 필요 )
	e.dep_no=d.dep_no

join -- 두개이상의 테이블에서 컬럼을 복사해서 횡으로 붙이는 작업<연관성있게 붙여서 작업>

<ANSI inner조인>

select
	e.emp_no			"직원번호"
	,e.emp_name			"직원명"
	,d.dep_name			"소속부서명"
from
	employee e inner join dept d
where
	e.dep_no=d.dep_no


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<91> 고객명, 고객전화번호, 담당직원명, 담당직원직급 을 출력 <조건> 담당직원이 있는 고객만 출력
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<주의> 담당직원이 있는 고객만 나와야하므로, 즉 조건에 맞는 행만 나와야하므로 inner 조인이다.
--------------------------------------------------------------------------
<오라클 조인>
--------------------------------------------------------------------------
select
	c.cus_name		"고객명"
	, c.tel_number		"고객전화번호"
	, e.emp_name		"담당직원명"
	, e.jikup			"담당직원직급"
from
	customer c, employee e
where
	c.emp_no=e.emp_no
----------------------------------------------------------------------------

--------------------------------------------------------------------------
<ANSI 조인>
--------------------------------------------------------------------------
select
	c.cus_name		"고객명"
	, c.tel_number		"고객전화번호"
	, e.emp_name		"담당직원명"
	, e.jikup			"담당직원직급"
from
	customer c inner join employee e
on
	c.emp_no=e.emp_no
----------------------------------------------------------------------------

(시험 및 면접에서) 조인할 수 있는 테이블의 개수? 개수는 상관없다 <함정주의>

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<92> 고객명, 고객전화번호, 담당직원명, 담당직원직급 을 출력 <조건> 10번 부서의 담당직원이 있는 고객만 출력
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
--------------------------------------------------------------------------
<오라클 조인>
--------------------------------------------------------------------------
select
	c.cus_name		"고객명"
	, c.tel_number		"고객전화번호"
	, e.emp_name		"담당직원명"
	, e.jikup			"담당직원직급"
from
	customer c, employee e
where
	c.emp_no=e.emp_no and e.dep_no=10
----------------------------------------------------------------------------

<주의> 오라클 조인에서 where 절에 조인 조건과 행을 골라내는 조건이 같이 나올 수 있다. and로 연결함

--------------------------------------------------------------------------
<ANSI 조인>
--------------------------------------------------------------------------
select
	c.cus_name		"고객명"
	, c.tel_number		"고객전화번호"
	, e.emp_name		"담당직원명"
	, e.jikup			"담당직원직급"
from
	customer c inner join employee e
on
	c.emp_no=e.emp_no
where
	e.dep_no=10
----------------------------------------------------------------------------

<주의>ANSI 조인에서 on절에 조인 조건을 쓰고, where 절에 행을 골라내는 조건을 씀. 

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<93> 고객명, 고객전화번호, 담당직원명, 담당직원직급 을 출력 <조건> 연봉이 3000만원 이상인 담당직원이 있는 고객
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

--------------------------------------------------------------------------
<오라클 조인>
--------------------------------------------------------------------------
select
	c.cus_name		"고객명"
	, c.tel_number		"고객전화번호"
	, e.emp_name		"담당직원명"
	, e.jikup			"담당직원직급"
from
	customer c, employee e
where
	c.emp_no=e.emp_no and e.salary>=3000
----------------------------------------------------------------------------



--------------------------------------------------------------------------
<ANSI 조인>
--------------------------------------------------------------------------
select
	c.cus_name		"고객명"
	, c.tel_number		"고객전화번호"
	, e.emp_name		"담당직원명"
	, e.jikup			"담당직원직급"
from
	customer c inner join employee e
on
	c.emp_no=e.emp_no
where
	e.salary>=3000
----------------------------------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<94> 직원부서명, 직원명, 직원직급, 담당고객명, 고객전화 출력 <조건> 직원 이름 오름차순 정렬
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

--------------------------------------------------------------------------
<오라클 조인>
--------------------------------------------------------------------------
select
	d.dep_name	"직원부서명"		
	, e.emp_name	"직원명"
	, e.jikup		"직원직급"
	, c.cus_name	"담당고객명"
	, c.tel_num	"고객전화번호"	
from
	dept d, employee e, customer c
where
	d.dep_no=e.dep_no and e.emp_no=c.emp_no
order by
	e.emp_name asc;
----------------------------------------------------------------------------


--------------------------------------------------------------------------
<ANSI 조인>
--------------------------------------------------------------------------
select
	d.dep_name	"직원부서명"		
	, e.emp_name	"직원명"
	, e.jikup		"직원직급"
	, c.cus_name	"담당고객명"
	, c.tel_num	"고객전화번호"
from
	(employee e inner join dept d on e.dep_no=d.dep_no) 
	inner join customer c on c.emp_no=e.emp_no
order by
	e.emp_name asc;
----------------------------------------------------------------------------

<ANSI 조인 주의> 3개 테이블부터 비대해져서 어려워짐


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<95> 직원명, 직원직급, 소속부서명, 연봉등급 출력 <조건> 연봉등급 오름차순, 직급 높은순서 오름차순, 나이 높은순서 내림차순 유지
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■ <-- 물어보기

--------------------------------------------------------------------------
<오라클 조인>
--------------------------------------------------------------------------
select		
	e.emp_name	"직원명"
	, e.jikup		"직원직급"
	, d.dep_name	"소속부서명"
	, s.sal_grade_no	"연봉등급"	
from
	employee e, dept d, salary_grade s
where
	e.dep_no=d.dep_no and (e.salary>=s.min_salary and e.salary<=s.max_salary)
order by
	s.sal_grade_no asc
	, decode(e.jikup, '사장', 1, '부장', 2, '과장', 3, '대리', 4, '주임', 5, 6 ) asc; 
	, case when substr( e.jumin_num,7,1) in ('1', '2') then '19' else '20' end 
	|| substr(e.jumin_num,1,6)) asc;
----------------------------------------------------------------------------
--------------------------------------------------------------------------
select		
	e.emp_name	"직원명"
	, e.jikup		"직원직급"
	, d.dep_name	"소속부서명"
	, s.sal_grade_no	"연봉등급"	
from
	employee e, dept d, salary_grade s
where
	e.dep_no=d.dep_no and (e.salary between s.min_salary and s.max_salary);
order by
	s.sal_grade_no asc
	, decode(e.jikup, '사장', 1, '부장', 2, '과장', 3, '대리', 4, '주임', 5, 6 ) asc; 
	, case when substr( e.jumin_num,7,1) in ('1', '2') then '19' else '20' end 
	|| substr(e.jumin_num,1,6) asc;
----------------------------------------------------------------------------

--------------------------------------------------------------------------
<ANSI 조인>
--------------------------------------------------------------------------
select
	e.emp_name	"직원명"
	, e.jikup		"직원직급"
	, d.dep_name	"소속부서명"
	, s.sal_grade_no	"연봉등급"
from
	(dept d inner join employee e on d.dep_no=e.dep_no) inner join
	salary_grade s on (e.salary between s.min_salary and s.max_salary);
order by
	s.sal_grade_no asc
	, decode(e.jikup, '사장', 1, '부장', 2, '과장', 3, '대리', 4, '주임', 5, 6 ) asc; 
	, case when substr( e.jumin_num,7,1) in ('1', '2') then '19' else '20' end 
	|| substr(e.jumin_num,1,6) asc;
----------------------------------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<96> 부하직원명, 부하직원직급, 직속상관명, 직속상관직급 출력<조건> 상관이 있는 직원만 포함
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

오라클 조인

select
	e1.emp_name		
	, e1.jikup			
	, e2.emp_name		
	, e2.jikup			
from
	employee e1, employee e2
where
	e1.mgr_emp_no=e2.emp_no;

ansi 조인
select
	e1.emp_name		
	, e1.jikup			
	, e2.emp_name		
	, e2.jikup			
from
	employee e1 inner join employee e2
on
	e1.mgr_emp_no=e2.emp_no;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<97> 직속상관명, 직속상관직급, 부하직원명, 부하직원직급 출력<조건> 상관이 있는 직원만 포함
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

select
	e1.emp_name		
	, e1.jikup			
	, e2.emp_name		
	, e2.jikup			
from
	employee e1, employee e2
where
	e1.emp_no=e2.mgr_emp_no

<95, 96> 고 난이도 문제 <주의>

같다라는 조건 -- equi조인

 '' 안왔을 때 -- non-equi조인

'한 쪽이 다 나와라' 이런거 아니면 inner join

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<98> 직원명, 직원직급, 소속부서명, 연봉등급, 직속상관명, 직속상관직급, 담당고객명 출력
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

select
	e1.emp_name		"직원명"
	, e1.jikup			"직원직급"
	, d.dep_name		"소속부서명"
	, s.sal_grade_no		"연봉등급"
	, e2.emp_name		"직속상관명"
	, e2.jikup			"직속상관직급"
	, c.cus_name		"고객명"
from
	employee1 e1, dept d, salary_grade s, employee e2, customer c
where
	e1.dep_no=d.dep_no
	and (e1.salary>=s.min_sal and e1.salary<=s.max_sal)
	and e2.emp_no=e1.mgr_emp_no
	and e1.emp_no=c.emp_no;

---------------------------------------------------------------------------------------------------------
select
	e1.emp_name		"직원명"
	, e1.jikup			"직원직급"
	, d.dep_name		"소속부서명"
	, s.sal_grade_no		"연봉등급"
	, e2.emp_name		"직속상관명"
	, e2.jikup			"직속상관직급"
	, c.cus_name		"고객명"
from
	(((employee e inner join dept d
	on e.dep_no = d.dep_no) inner join salary_grade s
	on e.salary between s.min_salary and s.max_salary) inner join employee e2
	on e.mgr_emp_no = e2.emp_no) inner join customer c
	on c.emp_no = e.emp_no

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<100> 고객명, 고객전화번호, 담당직원명, 담당직원직급 을 출력 <조건> 담당직원이 없는 고객도 출력
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<주의> 담당직원이 없는 고객도 포함 하라는 말은 고객은 다 나오라는 말이다. 즉, outer조인하라는 말이다.
	outer 조인은 한 쪽은 다 나오는 조인이다. 나머지는 조건에 안맞더라도 null 달고 나오라는 말이다.
-----------------------------------------------------------------------------------------------
select
	c.cus_name		"고객명"
	, c.tel_number		"고객전화번호"
	, e.emp_name		"담당직원명"
	, e.jikup			"담당직원직급"
	, e.dep_no		"부서번호"
from
	customer c, employee e
where
	c.emp_no=e.emp_no(+) -- 딸려 나오는 테이블 뒤에다가
-------------------------------------------------------------------------------------------------	
▶c.emp_no = e.emp_no(+) 의미
	(+)가 붙은 컬럼의 반대편 컬럼의 소속 테이블 행은 모두 나오고
	(+)가 붙은 e.emp_no 컬럼의 소속 테이블 행은 조건에 맞는 게 없으면 null이라도 달고 나오라는 뜻
	c.emp_no = e.emp_no(+)
--------------------------------------------------------------------------------------------------


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<101> 고객명, 고객전화번호, 담당직원명, 담당직원직급 츨력 
<조건> 고객정보는 모두 보이고 직원정보는 10번 부서만 보일 것
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

오라클 조인
-----------------------------------------------------------------------------------------
select
	c.cus_no
	, c.cus_name
	, c.tel_num
	, e.emp_name
	, e.jikup
	, e.dep_no
from
	customer c, employee e
where
	c.emp_no = e.emp_no(+) and e.dep_no(+)=10
------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------
<주의> outer 조인에서 where 에 (+)가 붙는 놈은?
-----------------------------------------------------------------------------------------------------
	where 절에 다나오는 메인 테이블이 아닌 모든 컬럼에 붙는다.
	심지어 행을 골라내는 조건의 컬럼도 여기에 속한다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<새끼문제>만약 e.dep_no(+)=10을 e.dep_no=10로 수정한다면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■


담당직원이 10번 부서인 고객만 포함된다.
마치 inner 조인의 결과 처럼 보인다.

ANSI 조인
--------------------------------------------------------------------------------
select
	c.cus_no
	, c.cus_name
	, c.tel_num
	, e.emp_name
	, e.jikup
	, e.dep_no
from
	customer c left outer join employee e
where
	c.emp_no = e.emp_no and e.dep_no=10;
--------------------------------------------------------------------------------
<주의> ANSI조인에서 left outer join 나오면 left outer join 왼쪽에 있는 테이블이 다 나오는 테이블이다
--------------------------------------------------------------------------------
<주의> ANSI조인에서 right outer join 나오면 right outer join 오른쪽에 있는 테이블이 다 나오는 테이블이다
--------------------------------------------------------------------------------
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<새끼문제>만약 e.dep_no=10 를 따로 빼내서 where e.dep_no=10 로 추가하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

where 절이 있으면 행을 골라내므로 고객이 2명만 나온다.
ANSI 방식의 outer 조인에서는 행을 골라내는 조건도 on 절에 들어가야한다.
만약에 where 절을 쓰면 메인 테이블이 다 나오지 않을 수 있다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<102> 고객번호, 고객명, 고객전화번호, 담당직원명, 담당직원직급, 담당직원연봉등급 츨력 
<조건> 담당직원이 없는 고객도 포함
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

select 	c.cus_no			"고객번호"
	, c.cus_name		"고객명"
	, c.tel_num		"고객전화번호"
	, e.emp_name		"담당직원명"
	, e.jikup			"담당직원직급"
	, s.sal_grade_no		"담당직원연봉등급"
from
	customer c, employee e, salary_grade s
where
	c.emp_no = e.emp_no(+)
	and
	s.min_salary(+)<=e.salary 
	and 
	s.max_salary(+)>=e.salary

<주의> employee 입장에서 메인 테이블은 customer 이고, salary_grade 테이블 입장에서 메인 테이블은 employee 이다.
	<메인에 딸려 나오는 테이블의 컬럼>에 (+)를 붙이면 된다.

<주의> 아래처럼은 안된다. 즉 <(+)를 양쪽에 붙일 순 없다.>
s.min_salary(+)<=e.salary(+) 
	and 
	s.max_salary(+)>=e.salary(+)

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<100> 고객번호, 고객명, 고객전화번호 출력. 단, 연봉이 3000이상인 담당직원이 담당한 고객이어야
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

select
	c.cus_no
	, c.cus_name
	, c.tel_num
from
	customer c, employee e
where
	e.salary>=3000 and e.emp_no<=c.emp_no

where에 and 사용 가능

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<101> 고객번호, 고객명, 고객주민번호 출력, 단 40살 이상인 담당직원 담당 고객이어야
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

select
	c.cus_no
	, c.cus_name
	, c.jumin_num
from
	customer c, employee e
where
	c.emp_no=e.emp_no
	and
	( extract( year from sysdate ) - extract( year from to_date
	( decode( substr( e.jumin_num,7,1), '1', '19', '2', '19', '20') || substr(e.jumin_num,1,6), 'YYYYMMDD') )+1 ) >=40

<주의> 코딩 상 분명히 조인 이지만 출력되는 컬럼은 <한개의 테이블에서 나오는 컬럼>이다.
	위 코딩은 조인이 출력 목적이 아니라 조건 목적으로 사용된 것이다.

<10부서 또는 30번 부서 직원이 담당하는 고객 정보 검색>


select
	c.cus_no
	, c.cus_name
from
	customer c, employee e
where
	c.emp_no=e.emp_no and
	(e.dep_no=10 or e.dep_no=30)
------------------------------------------------------------
select
	c.cus_no
	, c.cus_name
from
	customer c, employee e
where
	c.emp_no=e.emp_no and
	e.dep_no in(10, 30)

행을 골라주는 조건은 employee 테이블에 있기 때문에 join 사용


0622 스타트


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<104> 고객번호, 고객명, 담당직원번호, 담당직원명, 담당지원소속부서명, 담당직원연봉등급, 담당직원직속상관명,
담당직원직속상관직급, 직속상관연봉등급 출력
단, 고객은 다 나와야하고 null은 없응ㅁ으로 표시  -- nvl 사용
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<조인을 대표하는 문제>---<제일 중요함>
오라클 조인
----------
select
	c.cus_no
	, c.cus_name
	, nvl(to_char(e1.emp_no), '없음') "담당직원번호"
	, nvl(e1.emp_name, '없음')
	, nvl(d.dep_name, '없음')
	, nvl(to_char(s1.sal_grade_no), '없음')
	, nvl(e2.emp_name, '없음')
	, nvl(e2.jikup, '없음')
	, nvl(to_char(s2.sal_grade_no), '없음')
from customer c, employee e1, dept d, salary_grade s1, employee e2, salary_grade s2
where
	c.emp_no=e1.emp_no(+)
	and d.dep_no(+)=e1.dep_no
	and e1.mgr_emp_no=e2.emp_no(+)
	and e1.salary between s1.min_salary(+) and s1.max_salary(+)
	and e2.salary between s2.min_salary(+) and s2.max_salary(+)
order by c.cus_no asc;

부등호 나오기 시작하면 non-equi 조인

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<105>직원명, 직원번화번호와 고객명, 고객전화번호를 종으로 붙여 출력<조건> 중복하지 말것
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

select emp_name, phone from employee
union 
select cus_name, tel_num from customer

union  --- 중복된 행 제거 가능
컬럼 자료형이 같아야 붙여 줄 수 있음
컬럼 개수가 일치해야 붙여 줄 수 있음
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<106>직원명, 직원번화번호와 고객명, 고객전화번호를 종으로 붙여 출력<조건> 중복 허락
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

select emp_name, phone from employee
union all
select cus_name, tel_num from customer

union all --- 중복 행 허용

조건에 따라 이너 조인과 아우터 조인 결과가 같을 수도 있다


<107> 타 문서 페이지 참조
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<108> 최고 연봉 받는 직원 검색하라
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee
	where salary =(select max(salary) from employee);
	------------------------------------------------------
	서브쿼리 select max(salary) from employee 가 먼저 실행되고 난 후 리턴되는 최고연봉을 가지고 바깥 쿼리가 실행됨.
	위의 쿼리는 비상관쿼리이다.[서브쿼리] 실행 후의 결과값을 가지고 [외부 쿼리] 실행되기 때문이다.
	<주의> ~ where salary = max(salary); 이렇게 하면 안됨.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<109> 최고 연봉 받는 직원 검색하라
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee where salary >= (select avg(salary) from employee)

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<110> 20번 부서 최고 연봉자 직원 검색
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
	select * from employee 
	where salary = (select max(salary) from employee where dep_no=20) and dep_no=20;
	( o )
	select * from employee 
	where salary = (select max(salary) from employee where dep_no=20);
	( x - 문제가 바뀌게 된다<20번 부서의 최고 연봉자와 동일한 연봉을 받는 모든 직원 검색> )
위의 두 구문은 서로 나오는 결과값이 천지차이다.

바깥 쪽에서도 20번 부서 걸러낼 수 있는 걸 또 한번 만들어내야 원하는 답을 만들어낼 수 있다.<주의>

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<111> [직원명], [직급], [연봉], [전체연봉에서 차지하는 비율]을 검색. 4번째는 소수점 버림하고 %로 표현
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select
	emp_name							"직원명"
	, jikup								"직급"
	, salary								"연봉"
	, floor(salary/(select sum(salary) from employee) * 100) ||'%' "연봉비율"	"전체연봉에서 차지하는 비율"
from
	employee
order by
	floor(salary/(select sum(salary) from employee) * 100) desc
--------------------------------------------------------------------------------------------------------------------------------
select
	emp_name							"직원명"
	, jikup								"직급"
	, salary								"연봉"
	, trunc(salary/(select sum(salary) from employee) * 100,0) ||'%' "연봉비율"	"전체연봉에서 차지하는 비율"
from
	employee
order by
	salary/(select sum(salary) from employee) * 100) desc

<주의> 정렬할 때는 소수점 컨트롤하지 말고 소수점이 널부러지게하고 정렬해서 정확한 정렬이 된다.
<주의> 정렬할 때는 컬럼안에 들어있는 길이와 데이터를 참조해서 조심해서 해야 한다.(숫자 문자끼리 크고 작음 비교해야 할때)

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<112> 10번 부서 직원들이 관리하는 [고객번호], [고객명], [직원번호] 검색
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
조인

select
	c.cus_no, c.cus_name, c.emp_no
from
	customer c, employee e
where
	c.emp_no = e.emp_no and e.dep_no = 10;
-------------------------------------------------------------------------------------------------------
서브쿼리 중 비상관 쿼리 답
select
	c.cus_no, c.cus_name, emp_no
from
	customer c, employee e
where
	emp_no in( select emp_no from employee where dep_no=10 )
< 혹은 >
	emp_no= any( select emp_no from employee where dep_no=10 )
---------아래가 방금 꺼(0628)
select
	cus_no, cus_name, emp_no
from
	customer
where
	emp_no in( select emp_no from employee where dep_no=10 )
< 혹은 >
	emp_no= any( select emp_no from employee where dep_no=10 )

검색조건에 맞지 않는다고 에러가 뜨진 않는다. 단지 결과값이 나오지 않을 뿐이다.
in 오른쪽 또는 any 오른쪽에서 n행 1열에 서브쿼리가 실행되어야 함
-------------------------------------------------------------------------------------------------------
in 뒤에 n행 1열의 결과가 나오는 서브쿼리가 나오면 
n행 1열의 데이터가 in 뒤에 콤마(,)로 나열된다.
-------------------------------------------------------------------------------------------------------
서브쿼리 중 상관 쿼리
select
	c.cus_no,		c.cus_name,	c.emp_no
from
	customer c
where
	(select e.dep_no from employee e where c.emp_no = e.emp_no)=10;
-------------------------------------------------------------------------------------------------------
서브쿼리 중 상관 쿼리 
select
	c.cus_no,		c.cus_name,	c.emp_no
from
	customer c
where
	(select count(*) from employee e where c.emp_no = e.emp_no and e.dep_no=10)>0;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<113> 평균 연봉 이상이고 최대 연봉 미만의 [직원명], [연봉], [전체평균연봉], [전체최대연봉]을 출력
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select
	emp_name					"직원명"
	, salary						"연봉"
	, (select avg(salary) from employee) 전체평균연봉	"전체평균연봉"
	, (select max(salary) from employee) 전체최대연봉	"전체최대연봉"
from
	employee
where
	salary >=  (select avg(salary) from employee) 
	and 
	salary < (select max(salary) from employee);


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<114> 최고 연봉 직원의 [직원번호], [직원명], [부서명], [연봉]을 검색
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select
	e.emp_no		"직원번호"
	, e.emp_name		"직원명"
	, d.dep_name		"부서명"
	, e.salary			"연봉"
from
	dept d, employee e
where
	d.dep_no=e.dep_no and e.salary = ( select max(salary) from employee )

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<115> 담당 고객이 2명 이상인 [직원번호], [직원명], [직급]을 검색
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

select
	e.emp_no		"직원번호"
	, e.emp_name		"직원명"
	, e.jikup			"직급"
from
	employee e
where
	(select count(*) from customer c where e.emp_no = c.emp_no)>=2;

상관커리 - 바깥쪽 커리에 별칭 부여
where 절에서 결정( true 혹은 false 결정하는 구간 )

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<116> [직원번호], [직원명], [소속부서명]을 검색
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
-------------------------------------------------------------------------------------------------
조인
-------------------------------------------------------------------------------------------------
select
	e.emp_no		"직원번호"
	, e.emp_name		"직원명"
	, d.dep_name		"부서명"
from
	employee e, dept d
where
	e.dep_no=d.dep_no;	
-------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------
서브쿼리 답
select
	e.emp_no						"직원번호"
	, e.emp_name						"직원명"
	, (select d.dep_name from dept d where d.dep_no=e.dep_no)	"부서명"
from
	employee e;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<117> [직원번호], [직원명], [연봉], [연봉 순위]를 출력하면? 단 [연봉 순위]를 오름차순 유지
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

select
	e1.emp_no						"직원번호"
	, e1.emp_name						"직원명"
	, e1.salary						"연봉"
	, (select count(*)+1	 from employee e2 where e2.salary>e1.salary)	"연봉순위"
from
	employee e1
order by 4;
 --- 4번째 순서에 있는 것을 오름차순으로 정렬하라는 뜻

where 절 없다. = 순서대로 다 찍어줘라
select count(*) 조건에 맞는 모든 행을 나열하라

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<118> [직원번호], [직원명], [담당고객수] 출력
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■	

select
	e.emp_no						"직원번호"
	, e.emp_name						"직원명"
	, (select count(*) from customer c where c.emp_no=e.emp_no)	"담당고객수"
from
	employee e

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<119> [부서명], [부서직원수], [부서담당고객수] 출력
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■	

select
	d.dep_name
	, (select count(*) from employee e where e.dep_no=d.dep_no) ||'명'	"직원총수"
	, (select 
		count(*) 
	from 
		employee e, customer c
	where 
		e.dep_no=d.dep_no and e.emp_no=c.emp_no
	) ||'명'	"담당고객총수"
from
	dept d
order by
	2 desc;

프롬 절 뒤에 테이블이 2개 이상 왔어 - 조인
웨얼 뒤에 행을 골라내기 위한 조건 과 조인하기 위한 조건

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<120> [직원번호], [직원명], [직급], [주민번호], [직급서열순위] 를 출력
단, 직급이 같으면 나이 많은 직원이 [직급서열순위] 위이다. 그리고 [직급서열순위]를 오름차순 유지
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■	
★★★★★
select
	e1.emp_no
	, e1.emp_name
	, e1.jikup
	, e1.jumin_number
	, ( select count(*)+1 from employee e2
		where
		decode(e2.jikup, '사장', 1, '부장', 2, '과장', 3, '대리', 4, '주임', 5, 6)
		< decode(e1.jikup, '사장', 1, '부장', 2, '과장', 3, '대리', 4, '주임', 5, 6)
	or	
	( e2.jikup=e1.jikup and 
	to_number(decode(substr(e2.jumin_num,7,1),'1', '19', '2', '19', '20') || substr(e2.jumin_num,6,1) )
	<
	to_number(decode(substr(e1.jumin_num,7,1),'1', '19', '2', '19', '20') || substr(e1.jumin_num,6,1) )
	)
from
	employee e1
order by 5;
------------------------------------------------------------------------------------------------------------
ex. 1	홍길동	사장	~~	1
    2	한국남 	부장 	~~ 	2


자릿수가 똑같다면 같은 문자숫자끼리 정확한 비교 가능

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<120> 고객번호, 고객명, 고객전화번호, 담당직원명, 담당직원직급, 부서번호 출력 <조건> 담당직원 없는 고객도 포함
단, 조인 사용말고 서브쿼리 사용하십시오
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■	
서브쿼리 답
select
	c.cus_no
	, c.cus_name
	, c.tel_num
	, (select e.emp_name from employee e where c.emp_no=e.emp_no)
	, (select e.jikup from employee e where c.emp_no=e.emp_no)
	, (select e.dep_no from employee e where c.emp_no=e.emp_no)
from
	customer c;
조인 답
select
	c.cus_no
	, c.cus_name
	, c.tel_num
	, e.emp_name
	, e.jikup
	, e.dep_no
from
	customer c, employee e
where 
	c.emp_no = e.emp_no(+)


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<121> 고객번호, 고객명, 고객전화번호, 담당직원명, 담당직원직급, 부서번호 출력 
<조건> 고객정보는 모두 보이고 직원정보는 10번 부서만 보일 것
단, 조인을 사용하지 말고 서브쿼리를 사용하십시오
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■	
서브쿼리 답
select
	c.cus_no
	, c.cus_name
	, c.tel_num
	, (select e.emp_name from employee e where c.emp_no=e.emp_no and e.dep_no=10)
	, (select e.jikup from employee e where c.emp_no=e.emp_no and e.dep_no=10)
	, (select e.dep_no from employee e where c.emp_no=e.emp_no and e.dep_no=10)
from
	customer c;
order by 	1;
조인(오라클 조인)	
select
	c.cus_no
	, c.cus_name
	, c.tel_num
	, e.emp_name
	, e.jikup
	, e.dep_no
from
	cus





조인(ANSI 조인)






where 절을 쓰는 순간 행이 잘려나가서 on절에 붙여서 사용할 수 도 있다.



<122> group by
▶select 절에 있는 컬럼안의 중복 데이터를 [하나로 그룹]지어주는 역할을 한다.
▶주로 그룹을 지어 통계를 낼때 사용
▶group by 구문 문법은 간단하나 통계를 내는 과정에서 각종 함수가 때거리로 등장한다.
그러므로 group by 구문은 함수와의 싸움

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<123> 부서별로 [부서번호], [급여합], [평균급여], [인원수] 출력 단, 소수 2째 자리에서 반올림
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■	

select
	dep_no			"부서번호"
	, sum(salary)		"급여합"
	, round(avg(salary),1)	"평균급여"  ---  '1' 첫째자리에서 확인했으니 둘째 자리에서 반올림하란 뜻
	, count(*)			"인원수"
from employee
group by dep_no;

select 절에 일반 컬럼과 그룹함수 컬럼이 등장하면 group by 뒤에 반드시 그룹지을 일반 컬럼이 나와야 한다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<124> 직급별로 [직급], [급여합], [평균급여], [인원수] 출력
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■	

select
	jikup			"직급"
	, sum(salary)		"급여합"
	, round(avg(salary),1)	"평균급여"
	, count(*)	|| '명'		"인원수"
from employee
group by jikup;
	

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<125> 부서별, 직급별로 [부서번호], [직급], [급여합], [평균급여], [인원수] 출력
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■	

select
	dep_no			"부서번호"
	, jikup 			"직급"
	, sum(salary)		"급여합"
	, round(avg(salary),1)	"평균급여"
	, count(*)			"인원수"
from employee
group by
	dep_no, jikup


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<126> 부서별, 직급별로 [부서번호], [직급], [급여합], [평균급여], [인원수] 출력하되 인원수는 3명 이상 출력
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■	

select
	dep_no			"부서번호"
	, jikup 			"직급"
	, sum(salary)		"급여합"
	, round(avg(salary),1)	"평균급여"
	, count(*)			"인원수"
from 	employee
group by
	dep_no, jikup
having
	count(*)>=3;

where~~ --(where절 사용 가능) -- having 이전에 사용가능
----------------------------------------------------------------------------------------------------------
group by 결과물에서 행을 골라낼 때에는 where 를 쓰지 말고 having 을 사용한다.
----------------------------------------------------------------------------------------------------------
인라인 뷰 사용 예제
----------------------------------------------------------------------------------------------------------
select
	*
from
(
	select
		dep_no			DEP_NO
		, jikup 			JIKUP
		, sum(salary)		TOT_SALARY
		, round(avg(salary),1)	AVG_SALARY
		, count(*)			EMP_CNT
	from 
		employee
	group by
		dep_no, jikup
)
where
	EMP_CNT>=3

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<127> 부서별, 성별로 [부서번호], [성], [급여합], [평균급여], [인원수] 출력
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■	

select
	dep_no						"부서번호"
	, decode( substr( jumin_num,7,1),'1','남','3','남','여')	"성"
	, sum(salary)					"급여합"
	, round(svg(salary),1)				"평균급여"
	, count(*)	|| '명'					"인원수"
from employee
group by
	dep_no, decode( substr( jumin_num,7,1),'1','남','3','남','여')


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<128> 입	사년도별로 [입사년도], [인원수]를 출력하고 년도별로 오름차순
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■	

select
	hire_date 
	, count(*)
from
	employee
group by
	hire_date 
order by 1

select
	to_char(hire_date, 'YYYY' ) 	"입사년도"
	, count(*)			"인원수"
from
	employee
group by
	to_char(hire_date, 'YYYY' )
order by 
	"입사년도" asc;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<129> 부서별로[부서번호], [평균근무년수]를 출력(근무년수는 소수점 2째 자리에서 반올림할 것)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■	

select
	dep_no
	, round(avg( (sysdate-hire_date)/365 ) , 1) || '년 근무'
from employee
group by dep_no;	
---------------------------------------------------------------------------------------------------
select
	dep_no							"부서번호"
	, round(       avg( (sysdate-hire_date)/365 ) , 1) || '년'		"평균근무년수"
from employee
group by dep_no;	


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<130> 입사분기별로 [입사분기], [인원수] 출력
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

select
	to_char( hire_date, 'Q' ) || '분기'				"입사분기"
	, count(*)							"인원수"
from
	employee
group by
	to_char( hire_date, 'Q' ) || '분기'	

to_char( hire_date, 'Q' ) || '분기' -- 분기 만드는 구문 <중요>


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<131> 입사연대별, 성별로 [입사연대], [성], [연대별입사자수] 출력
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

select
	trunc(extract(year from hire_date), -1)				"입사연대"
	, decode(substr(jumin_num,7,1),'1','남','3','남','여')		"성별"
	, count(*) 						"연대별입사자수"
from
	employee
group by
	trunc(extract(year from hire_date), -1), decode(substr(jumin_num,7,1),'1','남','3','남','여')
oreder by	"입사연대";

select
	substr( to_char( hire_date, 'YYYY' ), 1, 3 ) || '0년대'	"입사연대"
	, decode(substr(jumin_num,7,1),'1','남','3','남','여')	"성별"
	, count(*) 					"연대별입사자수"
from
	employee
group by 
	substr( to_char( hire_date, 'YYYY' ), 1, 3 ) || '0년대'
	, decode(substr(jumin_num,7,1),'1','남','3','남','여')


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<132> [직원명], [입사일](년-월-일 ~/4분기 ~요일), [퇴직일](년-월-일) 출력 
<조건> 퇴직일은 입사 후 20년 5개월 10일 후
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select 
	emp_name
	, to_char(hire_date, 'YYYY-MM-DD Q' ) || '/4분기' ||
		to_char(hire_date, 'DAY', 'NLS_DATE_LANGUAGE = Korean')
	, to_char(
		add_months( hire_date, 5 + 20*12 ) + 10, 'YYYY-MM-DD' )
from employee;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<133> 직원들이 있는 부서별로 [부서번호], [부서위치], [직원수] 출력 <조건> 모든 부서 다 나오도록
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

select
	d.dep_no 				"부서번호"
	, d.loc					"부서위치"
	, count(e.emp_name)			"직원수"
from
	employee e, dept d
where
	e.dep_no(+) = d.dep_no
group by
	d.dep_no, d.loc;
----------------------------------------------------------------------------------------------------------------
select
	d.dep_no							"부서번호"
	, d.loc							"부서위치"
	, (select count(*) from employee e where e.dep_no=d.dep_no)	"직원수"
from dept d




■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<134> 월별로 [입사월], [인원수]를 검색
<조건> 입사월 오름차순 유지
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

select
	to_char(hire_date, 'MM') || '월'		"입사월"
	, count(*)					"입사인원수"
from
	employee
group by 
	to_char(hire_date, 'MM') || '월'
order by 
	"입사월" asc;	
------------------------------------------------------------------------------------------------------------
새끼문제-- 위 문제의 답에서 없는 달은 나오지 않는다.
	  없는 달도 포함하여, 즉 1~12월까지 다 나오게 하려면?
------------------------------------------------------------------------------------------------------------
group by, join 사용
------------------------------------------------------------------------------------------------------------
select
	m.month||'월'		"입사월"
	, count(e.emp_name)	"입사인원수"
from
	(
		select "01" "MONTH" from dual union
		select "02" from dual union select "03" from dual union select "04" from dual union
		select "05" from dual union select "06" from dual union select "07" from dual union
		select "08" from dual union select "09" from dual union select "10" from dual union
		select "11" from dual union select "12" from dual union
	) m
	, employee e
where
	to_char(e.hire_date(+), 'MM')=m.month
group by
	m.month||'월'
order by
	"입사월";
------------------------------------------------------------------------------------------------------------
상관쿼리 사용
------------------------------------------------------------------------------------------------------------
select
	m.month||'월'								"입사월"
	, (select count(*) from employee e where to_char(e.hire_date, 'MM')=m.month) 	"입사인원수"
from
(
	select "01" "MONTH" from dual union
	select "02" from dual union select "03" from dual union select "04" from dual union
	select "05" from dual union select "06" from dual union select "07" from dual union
	select "08" from dual union select "09" from dual union select "10" from dual union
	select "11" from dual union select "12" from dual union
) m


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<135> employee 테이블에서 직급순서대로 정렬하여 직급별로 [직급], [직급평균연봉], [인원수]를 검색
(높은 직급이 먼저 나와야 함.)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

select
	jikup			"직급"
	, round(avg(salary), 1) 	"직급평균연봉"
	, count(*)			"인원수"
from		employee
(where		~~~~)
group by		jikup
having 		count(*)>=5
order by	
	decode(jikup, '사장', 1, '부장', 2, '과장', 3, '대리', 4, '주임', 5, 6) asc;
decode("직급", '사장', 1, '부장', 2, '과장', 3, '대리', 4, '주임', 5, 6) asc;

★ * 나오면 그룹 지으란 뜻 -- 예외 존재
중복된 직급 제거
직급별로 평균연봉 갯수
order 사용 시 오라클이 인식하지 못하는 순서관계를 출력해야 할 경우 작성자가 직접 특정 구문(ex, decode, case when 등)
을 사용하여 정렬기준을 새로 잡아주어야 함.
order by는 항상 맨 밑으로 위치시켜야
알리아스'별칭'은 오더 뒤에

소수점 컨트롤
보고싶은 자리수 기준
그룹 바이에서 나온 결과물에서 '행'을 골라내는 것
가공된 컬럼의 경우 그대로 붙여서 사용

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<136> 부서별 [부서번호], [부서명], [직원수], [직원이 관리하는 고객수] 검색
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select
	d,dep_no					"부서번호"
	, d.dep_name				"부서명"
	, count(distinct e.emp_no)			"직원수"    -- distinct 통해 중복된 것 제거하기 위해
	, count(c.emp_no)				"직원이 관리하는 고객수"  -- 
from	dept d, employee e, customer c
where	d.dep_no=e.dep_no(+) and c.emp_no(+)=e.emp_no
group by
	d,dep_no, d.dep_name


'부서별'이란 말은 있는데 --- 직원이 없는 부서가 있을 수 있음 --- 이것을 다 포함해서 통계를 내야 함
--- 문제 속에 outer join을 하라는 뜻이 담겨 있음
단일칼람 - 그룹을 있어야 

count(c.emp_no)에  distinct 쓰면 고객 담당하는 직원수 된다

count(distinct e.emp_no) 에 distinct 안하면 직원수 중복된다

select
	d,dep_no												"부서번호"
	, d.dep_name											"부서명"
	, (select count(*) || '명' from employee e where e.dep_no=d.dep_no) 					"부서직원수"
	, (select count(*) || '명' from employee e, customer c where e.dep_no=d.dep_no and e.emp_no=c.emp_no) 	"담당고객수"
from dept d;


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<137> 퇴직일이 60세 라는 기준 하에 아래처럼 출력하라  <중요도 ★★★★★★★★★★ >
[직원번호], [직원명], [근무년차], [퇴직일까지 남은 년도], [생일(년-월-일 요일명)], [소속부서명], [직속상관명], [직속상관 부서명]
----------------------------------------------------------------------------------- -------------  -------------  ------------------
				employee e1			     dept d1    employee e2      dept d2
				    메인 <<-------------------------------------		   |   <<-----------		
					<<---------------------------------------------------|					
단 모든 직원 다 나오고, 직급 높은 사람 먼저 나오고 직급 같으면 나이가 많은 사람이 나와야 함.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

select
	e1.emp_no																																			"직원번호"
	, e1.emp_name																																	"직원명"
	, ceil((sysdate-e1.hire_date)/365) 	--구한 후 소수점을 무조건 올림하기 위해 ceil 사용																					"근무년차"
	, to_number(to_char(sysdate,'YYYY'))  
	-to_number((case substr(e1.jumin_num,7,1)	--현재 이시각 년도
	when '1' then '19' when '2' then '19'else '20'end)
	||substr(e1.jumin_num,1,2))+1 																								"나이"
	, 60-(to_number(to_char(sysdate,'YYYY')) 	--퇴직일에서 ~~~ 빼기
	-to_number((case substr(e1.jumin_num,7,1)
	when '1' then '19' when '2' then '19'else '20'end)
	||substr(e1.jumin_num,1,2)))+1																								"퇴직일까지남은년도"
	, to_char(to_date(case substr(e1.jumin_num,7,1)  
		when '1' then '19' when '2' then '19' else '20' end
			||substr(e1.jumin_num,1,6),'yyyymmdd'),'yyyy-mm-dd')||' '	
			||to_char(to_date(case substr(e1.jumin_num,7,1) 
				when '1' then '19' when '2' then '19' else '20' end
			||substr(e1.jumin_num,1,6),'yyyymmdd'),'dy','nls_date_language = korean')	"생일"
	,e1.jikup       									"직급"
	,d1.dep_name 											"소속부서명"
	,e2.emp_name  										"직속상관명"
	,d2.dep_name   										"직속상관소속부서명"
from	
	employee e1, dept d1, employee e2, dept d2
where	
	e1.dep_no = d1.dep_no(+)
	and
	e1.mgr_emp_no = e2.emp_no(+)
	and
	e2.dep_no = d2.dep_no(+)
order by
	decode(e1.jikup, '사장', 1, '부장', 2, '과장', 3, '대리', 4, 5) asc
	, case substr(e1.jumin_num,7,1) when '1' then '19' when '2' then '19' else '20' end || substr(e1.jumin_num,1,6) asc





어려울 땐 일단 한글로 쳐서 본 다음에 차근차근 코딩해 보기
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<139> [인라인 뷰(inline view)]란?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
from 절에 나오는 select를 말한다.
from절에는 테이블명이 나온다. 
이 자리에 select 나올 경우 select 결과물을 테이블로 생각하면 된다.
인라인뷰는 select 결과물을 테이블로 취급하기 때문에 메모리에 부담을 준다.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<140> 연봉 서열대로 직원을 검색하되 1행부터 10행 까지만 검색하면
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
답1
조회된 순서대로 순서가 매겨지는 것 -- rownum

------------------------------------------------------------------------------------------------------------
select
	*
from
(
	select
		rownum RNUM, e.*
	from
		(select * from employee order by salary desc) e
	where
		rownum<=10
)
where
	RNUM>=1
------------------------------------------------------------------------------------------------------------
답2 => 답1보다 2~3배 정도 느리다
------------------------------------------------------------------------------------------------------------
select
	*
from
(
	select
		rownum RNUM, e.*
	from
		(select * from employee order by salary desc) e
)
where
	RNUM>=1 and RNUM<=10;
------------------------------------------------------------------------------------------------------------
오라클은 모든 select 결과물에 rownum 컬럼을 붙여준다. 
이 컬럼 안에는 1부터 시작하는 일련번호가 들어가 있다.
------------------------------------------------------------------------------------------------------------

rownum 컬럼이 where 절에 들어갈 때 주의사항
------------------------------------------------------------------------------------------------------------
order by 가 있을 경우 정렬된 후에 rownum 컬럼이 붙는 게 아니라
정렬되기 전에 rownum 컬럼이 붙고 난 후 정렬이 된다
그러므로 rownum 컬럼 안의 일련 번호 뒤 엉켜 버린다
------------------------------------------------------------------------------------------------------------
	rownum 자리에 1이 들어가서 false 가 나오는 조건이 있다면조건이 성립되지 않는다.
------------------------------------------------------------------------------------------------------------
	<예> 
		where rownum<=3 (O)
		where rownum=1 (O)	
		where rownum>=3(X)	
		where rownum>1(X)	
		where rownum=2(X)
		where rownum>=1 and rownum<=3 (O)
		where rownum>=2 and rownum<=3 (X)
------------------------------------------------------------------------------------------------------------
인라인 뷰, 즉 from 절에 나오는 select는 바깥쪽 select 입장에서는 테이블처럼 생각한다.
인라인 뷰 안에 rownum 컬럼이 있다면 바깥쪽 select 입장에서 안쪽 rownum 컬럼은 단순한 일반 컬럼이 된다.
------------------------------------------------------------------------------------------------------------
<참고문제> 이렇게 n행~m행 까지 검색하는 이유는?
------------------------------------------------------------------------------------------------------------
	실제로는 select의 결과물이 웹브라우저로 출력된다.
	만약 select 결과물이 100,000 행이면 다 보여줄 경우 웹브라우저 로딩이 걸린다.
	그러므로 1~10행 또는 1행~15행 씩 끊어서 웹브라우저로 출력되야 로딩이 걸리지 않는다.
	이렇게 select결과물에서 n행씩 끊어서 화면에 보여주는 것은 [페이징] 처리라고 한다.<중요>
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
<패턴>n행~m행 까지 검색하는 select 패턴 정리1
------------------------------------------------------------------------------------------------------------
select * from ( select rownum RNUM, zxcvb.* from (
	원하는 정렬 select 문
) zxcvb where rownum<=마지막행번호 ) where RNUM>=시작행번호;
------------------------------------------------------------------------------------------------------------
<패턴>n행~m행 까지 검색하는 select 패턴 정리2
------------------------------------------------------------------------------------------------------------
select * from ( select rownum RNUM, zxcvb.* from (
	원하는 정렬 select 문
) zxcvb) where RNUM>=시작행번호  where RNUM<=마지막행번호;
------------------------------------------------------------------------------------------------------------
ex.
select * from (select rownum RNUM, e.* from (
	select * from employee order by salary desc
) e where rownum<=10 ) where RNUM>=1;
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
<새끼>고객 나이 서열 중 6행 부터 10행 까지 검색
select * from ( select rownum RNUM, zxcvb.* from (

	select * from customer
	order by
		decode(substr(jumin_num,7,1),'1','19','2','19','20')||substr(jumin_num,1,6)asc

) zxcvb where rownum<=10 ) where RNUM>=6;
------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------
<새끼>직원 직급 서열 중 2~5행 까지 검색
select * from ( select rownum RNUM, zxcvb.* from (

	select * from employee
	order by
		decode(jikup, '사장', 1, '부장', 2, '과장', 3, '대리', 4, '주임', 5, 6)

) zxcvb where rownum<=5 ) where RNUM>=2;


오라클이 모든 컬럼명에 붙여주는 일련번호 -- rownum
ordre by와 같이 사용 시 일련번호가 뒤엉킬 수 있다.	- 단점
where절에서 rownum을 사용할 때 1을 넣어서 false가 나오면 검색이 안된다.
그래서 인라인 뷰를 통해 2,3중으로 감싸야 할 필요가 있다.		-단점



■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<141> 오늘부터 10일 이후까지 날짜 중에 토요일, 일요일, 월요일을 제외한 날의 개수를 구하면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select count(*) from (
	select sysdate "XDAY" from dual
	union select sysdate+1 from dual 	union select sysdate+2 from dual 
	union select sysdate+3 from dual 	union select sysdate+4 from dual 
	union select sysdate+5 from dual 	union select sysdate+6 from dual 
	union select sysdate+7 from dual 	union select sysdate+8 from dual 
	union select sysdate+9 from dual 	union select sysdate+10 from dual
) d
where
	to_char( d.xday, 'dy', 'nls_date_language = korean')!='토'
	and to_char( d.xday, 'dy', 'nls_date_language = korean')!='일'
	and to_char( d.xday, 'dy', 'nls_date_language = korean')!='월'

select count(*) from ( select 컬럼 "대문자 별칭 컬럼" from dual
	union select 컬럼+1 from dual(가상테이블)
	union select 컬럼+2 from dual(가상테이블)
	.
	.
	.
	union select 컬럼+n from dual(가상테이블)
) d
where
	요구되는 함수 구문 식 and and ~~
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<142> 이번달 중에 토요일, 일요일을 제외한 날의 개수를 구하면? = 이번달 평일 수 구하기
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
select 
	count(*) 
from 
	(
	select to_date(to_char(sysdate, 'YYYY-MM')||'-01', 'YYYY-MM-DD')+RNUM-1 "XDAY"
	from
	(
	select rownum RNUM from employee union select rownum+20 from employee)
	where RNUM<=to_number(to_char(last_day(sysdate).'dd') -- 이번달 말일 숫자 구하는 구문
	)
	)d
where
	to_char( d.xday, 'dy', 'nls_date_language = korean')!='토'
	and to_char( d.xday, 'dy', 'nls_date_language = korean')!='일'	
	and XDAY <= last_day(sysdate)

<정석버전>
select to_date(to_char(sysdate, 'YYYYMM')||'01'YYYYMMDD') from dual
union select to_date(to_char(sysdate, 'YYYYMM')||'01'YYYYMMDD')+1 from dual


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<143> VIEW가 무엇(기,입,실)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
● 실시간으로 select 결과물을 테이블처럼 가장해서 보여주는 [테이블]이다. [가상 테이블]이라고도 한다.
● <144>view 특징 	- 객체로써 저장된다. 즉, 이름을 가지고 저장된다.
		- 뷰도 테이블이므로 select 대상이 된다.
		- 뷰의 근원이 되는 실존 테이블의 데이터가 변경된 후 뷰가 실행되면 뷰에 그대로 반영된다.
		(=실존 테이블과 view는 항상 동기화 한다.)
		- 뷰를 가지고 또 다른 뷰를 만들 수 있다.
● <145>view 사용 목적	- 특정 컬럼을 보여주고 싶지 않을 때 활용(보안성 확보)
		ex. abc계정이 employee 테이블에서 salary 만 빼고 다보이게 하려면 salary 만 뺀 select 구문을
		employee_vw 라는 이름의 view로 만들어 저장하고 employee_vw에 select권한을 주고,
		employee 테이블에는 select권한을 주지 않으면 abc계정이 employee 테이블에서
		salary 만 빼고 다 보게 할 수 있다.
		- join과 같은 길고 복잡한 select문장을 뷰로 만들어 테이블어 처럼 사용되어 [편의성]을 제공
		
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<146> employee 테이블로부터 salary 컬럼만 제외하고 다 볼수 있는 뷰 employee_vw1를 생성하면
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

create view employee_vw1 as
	select 
		emp_no, emp_name, dep_no, jikup, jire_date, jumin_num, phone, mgr_emp_no
	from 
		employee

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<147> employee_vw1에 데이터 '이승엽', 40, '과장', '1990-09-01', 7811231452719', '01090056376',1를 입력
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
뷰에 insert를 하면 뷰의 근원이 되는 원본 테이블에 insert 된다.
무조건 insert 되는 것은 아니며  원본 테이블에 insert되는 상황이어야 한다.
(자료유형, 제약조건, 자료형의 크기(길이) 등이 동일하게 충족되어야 한다.)
----------------------------------------------------------------------------------------------------------
insert into employee_vw1 (
	emp_no, emp_name, dep_no, jikup, hire_date, jumin_num, phone, mgr_emp_no
)values(
	(select nvl(max(emp_no),0)+1 from employee_vw1 )
		,'이승엽',40,'과장',to_date('1990-90-01','YYYY-MM-DD'), '7811231452719', '01090056376', 1
	);
----------------------------------------------------------------------------------------------------------
비록 뷰 employee_vw1에 insert를 했지만 실제로는 employee 테이블에 입력된 것이다.		
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<14?> 부서별, 직급별로 [부서번호], [부서명], [직급], [평균연봉] 을 출력하는 뷰 employee_vw3를 생성
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
-- order by 원리 물어볼 것
create view employee_vw3 as 
	select 
		d.dep_no 	"dep_no"
		, d.dep_name 	"dep_name"
		, e.jikup 		"jikup"
		, avg(e.salary) 	"avg_salary"
	from 							
		employee e,  dept d
	where 
		e.dep_no=d.dep_no
	group by 
		d.dep_no , d.dep_name, e.jikup
	order by  
		"dep_no", "avg_salary" desc

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<148> 뷰 employee_vw1에서 주민번호 '7811231452719', 직원명 '이승엽'의 직급을 부장으로 수정
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
뷰에 update를 하면 뷰의 근원이 되는 원본테이블에 update된다.
무조건 update되는 것은 아니며  원본 테이블에 update되는 상황이어야 한다.
------------------------------------------------------------------------------------------------------------
update 테이블명 set 컬럼명 = 수정데이터, ~ where 조건식

set 컬럼명 - 바꿔야 할 컬럼					]
= 수정데이터 - 요구되는 데이터				] 이렇게 이해함
where 조건식 - 바꿔야 할 데이터의 같은 행에 속하는 조건들 	]

update employee_vw1 set jikup = '부장'  where emp_name = '이승엽' and jumin_num = '7811231452719'

select * from employee;
select * from employee_vw1;

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<149> 뷰 employee_vw1에서 주민번호 '7811231452719' 인 직원을 제거
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
뷰에 delete를 하면 뷰의 근원이 되는 원본테이블에 delete된다.
무조건 delete되는 것은 아니며  원본 테이블에 delete되는 상황이어야 한다.
그 행의 pk번호를 누군가 참조하고 있는지 확인해야(pk, fk 번호 확인)
------------------------------------------------------------------------------------------------------------
delete from employee_vw1 where jumin_num='7811231452719';

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<150>뷰 employee_vw1를 제거하면
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
drop 다음엔 객체명
drop view employee_vw1;
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<151>다음 뷰에 대한 질문에 대한 답 
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

create view employee_vw4 as
select emp_no, emp_name, dep_no from employee;
<문>위의 뷰를 만든 후 insert into employee_vw4 values( 21, '사오순', 40); 실행하면 성공 or 실패?
-> 실패. 뷰 employee_vw4에 입력되는 데이터는 employee 테이블에 입력되는 것과 같다.
employee 테이블에서 not null, unique 등의 제약조건에 위반되기 때문에 못들어간다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<152>다음 뷰에 대한 질문에 대한 답 
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

insert into dept values(60, '전략부', '부산');
------------------------------------------------------------------
create view dept_vw1 as
	select dep_no, dep_name, loc from dept
	where dep_no=60 with check option;
------------------------------------------------------------------
<문> update dept_vw1 set dep_no=70 where dep_no=60;을 실행하면?
------------------------------------------------------------------
▶실패. with check option 이 있으면 where 조건에 위배되는 입력, 수정은 불가능하다. --<중요>
▶즉, dept_vw1 란 이름의 view의 목적은 60번 부서를 검색하는 게 목적이므로 이 목적 위배하는 행위는 하지마라
위배하면 60번 부서를 검색하지 못하게 되니까 위배하지 마라의 의미 있다.
------------------------------------------------------------------
<문> insert into dept_vw1 values(70, '미래부', '대구' ); 을 실행하면?
------------------------------------------------------------------

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<153>다음 뷰에 대한 질문에 대한 답 (기, 입)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
------------------------------------------------------------------
create view employee_vw6 as
	select emp_no, emp_name, dep_no, jikup, salary from employee where salary>=3000
with check option;
------------------------------------------------------------------
<문> update employee_vw6 set salary=salary*0.95 where salary>=3000을 실행하면?
------------------------------------------------------------------
▶실패. with check option이 있으면 where 조건에 위배되는 입력, 수정이 발생할 결우에만 불가능하다.
▶현재 5% 인하해서 3000밑으로 내려가는 직원이 있으므로 이번 update는 실패한다.
▶만약 5% 인하해서 3000밑으로 내려가는 직원이 없다면 이 update는 성공할 것이다.
------------------------------------------------------------------
<문> update employee_vw6 set salary=salary*1.95 where salary>=3000을 실행하면?
------------------------------------------------------------------
▶성공. 업데이트로 3000미만으로 내려가지 않아 조건에 위배되지 않으므로 성공한다.
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<154>다음 뷰에 대한 질문에 대한 답 (기, 입)
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
------------------------------------------------------------------
create view employee_vw7 as
	select emp_no, emp_name, dep_no, jikup, salary from employee where salary>=3000
with check option;
------------------------------------------------------------------
<문>update employee_vw7 set salary=salary*0.95 where salary>=3100을 실행하면?
------------------------------------------------------------------
▶성공, with check option이 있으면 where 조건에 위배되는 입력, 수정이 발생할 경우에만 불가능하다.
▶현재 5% 인하해서 3100 밑으로 내려가는 직원이 없으므로 이번 update는 성공한다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<155> 뷰를 만드는 SQL 문법
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
-----------------------------------------------------------------------------------------------
CREATE [OR REPLACE] [FORCE | NOFORCE] VIEW 뷰이름 AS select문장 [WITH READ ONLY] [WITH CHECK OPTION];
-----------------------------------------------------------------------------------------------
▶OR REPLACE
	- 동일한 뷰가 있으면 덮어쓴다. 즉 기존의 뷰가 갱신된다. 미사용 시 뷰 생성 불가능.
▶FORCE
	- 존재하지 않는 테이블로부터 뷰를 만들 경우라도 뷰를 만든다.
	- FORCE에 의해 생성된 뷰를 select로 검색하면 에러가 발생한다.
	즉, 이름만 존재하고 검색이 불가능한 뷰가 된다.
	- 뷰 생성 시 거론한 존재하지 않는 테이블을 나중에 만들고 나면
	뷰도 select로 검색이 가능하다.
▶NOFORCE
	- 존재하지 않는 테이블에서 뷰를 만들 경우 뷰를 만들지 못한다.
	- FORCE, NOFORCE 모두 생략 시 NOFORCE 설정과 같다.
▶WITH READ ONLY
	- 뷰에 대해 입력, 수정, 삭제 작업이 불가능하다.
	- 생략 시 특정 조건하에 하나의 테이블에서 만들어진 뷰에 대해서는 입력, 수정, 삭제 작업을 할 수 있고
	실존 테이블에 입력, 수정, 삭제가 된다.
▶WITH CHECK OPTION
	- 뷰의 WHERE 구문 조건에 위배되는 방향으로 INSERT, UPDATE 작업은 불가능하다.
	- <예> 뷰에 where salary>=6000 이 있을 경우 salary>=6000 조건에 위배되는 방향으로 입력, 수정이 불가능하다
	예를 들어 salary>=6000 조건에 해당하는 행의 salary를 6000미만으로 입력, 수정하는 행위는 불가능하다
▶생성한 뷰의 정보 검색 방법
	- select view name, tect from user views ;
▶select 문에서 실존 테이블에 존재하지 않는 컬럼은 반드시 별칭을 써야한다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<156> employee 테이블에 '장보고', 40, '대리', 3500, '2012-05-28', '8311091109310', '01092499215', 3 입력
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
----------------------------------------------------------------------------------
시퀀스 사용하여 pk값을 입력하는 예
----------------------------------------------------------------------------------
	insert into employee( 
	    emp_no, emp_name, dep_no, jikup, salary, hire_date, jumin_num, phone, mgr_emp_no 
	)
	values( 
	    emp_sq.nextval, '장보고', 40, '대리', 3500, to_date('2012-05-28','YYYY-MM-DD'), '8311091109310', '01092499215', 3 
	);
----------------------------------------------------------------------------------
서브쿼리를 사용하여 pk값을 입력하는 예
----------------------------------------------------------------------------------
	insert into employee( 
	    emp_no, emp_name, dep_no, jikup, salary, hire_date, jumin_num, phone_num, mgr_emp_no 
	)
	values( 
	    (select nvl(max(emp_no),0)+1 from employee), 
		'장보고', 40, '대리', 3500, to_date('2012-05-28','YYYY-MM-DD'), '8311091109310', '01092499215', 3 
	);
----------------------------------------------------------------------------------
select * from employee; 	--> insert 확인.
commit;			--> insert 작업 인정. insert 작업 취소 시 rollback; 실행.	

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<157> employee 테이블에 직원번호가 18번이고 주민번호 8203121977315, 이름 강감찬 직원의 직급을 주임으로 수정
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
----------------------------------------------------------------------------------
주민번호로 찾아서 수정한 경우 (좋은 답은 아니다 - 주민번호가 DBA가 준 값이 아니므로 신뢰도가 떨어지기 때문)
----------------------------------------------------------------------------------
update
	employee
set
	jikup='주임'
where
	emp_name = '강감찬' and jumin_num = '8203121977315';
----------------------------------------------------------------------------------
pk값으로 찾아서 수정한 경우 (옳은 답 - PK는 DBA가 준 값이라 신뢰도가 높기 때문)
----------------------------------------------------------------------------------
update
	employee
set
	jikup='주임'
where
	emp_no = 18;
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<158>여성 직원의 월급을 500만원 인상하는 update문은?  <남, 녀 성별 구하는 구문 참조>
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
update
	employee
set
	salary = salary + 500
where
	substr(jumin_num,7,1)='2' or substr(jumin_num,7,1)='4'
----------------------------------------------------------------------------------
update
	employee
set
	salary = salary + 500
where
	substr(jumin_num,7,1) in ('2','4') 
----------------------------------------------------------------------------------
update
	employee
set
	salary = salary + 500
where
	substr(jumin_num,7,1) = any ('2','4') 
----------------------------------------------------------------------------------
update
	employee
set
	salary = salary + 500
where
	jumin_num like '______2%' or jumin_num like '______4%'


■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<159> employee 테이블에서 평균 연봉 이상의 직원 연봉을 2% 삭감 <평균연봉 서브쿼리(비상관쿼리) 참조>
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
연봉 관련 구문 작성 예시 select avg,min,max 기타 등등(salary) from ~~~ 형식
update
	employee
set
	salary = salary*0.98
where
	salary>=(select avg(salary) from employee);
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<160> employee 테이블에서 평균 연봉보다 적은 연봉자의 연봉을 50만원 인상
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
update
	employee
set
	salary = salary + 50
where
	salary<(select avg(salary) from employee);
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<161> 담당 고객이 있는 직원의 급여를 5% 인상
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
update
	employee
set
	salary = salary * 1.05
where
 	emp_no in( select distinct emp_no from customer where emp_no is not null )
--------------------------------------------------------------------------------------------------------
update
	employee
set
	salary = salary * 1.05
where
 	emp_no=any( select distinct emp_no from customer where emp_no is not null )
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<162> 연봉 서열 2~5위 5명의 연봉을 10% 인하. 
정렬 기준=>연봉 높은 순서>직급 높은 순서>입사일 빠른 순서>나이 높은 순서
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
update
    employee
set
    salary = salary * 0.9
where
    emp_no in (
        select
        emp_no
        from
        (
        select
          rownum RNUM
          , zxcvb.*
        from (
          select emp_no
          from employee
          order by
          salary desc
          , decode(jikup, '사장', 1, '부장', 2, '과장', 3, '대리', 4, '주임', 5, 6) asc
          , hire_date asc
          , decode(substr(jumin_num,7,1),'1','19','2','19','20')||substr(jumin_num,1,6) asc
        ) zxcvb where rownum <=5 ) where RNUM >= 2
    );
-------------------------------------------------------------------------------------------------------------------
 update
	employee
set
	salary = salary * 0.9
where
	emp_no in(
		select emp_no from ( select rownum RNUM, zxcvb.* from (

			select emp_no from employee
			order by
			salary desc
			, decode(jikup, '사장', 1, '부장', 2, '과장', 3, '대리', 4) asc
			, hire_date asc
			, decode(substr(jumin_num,7,1), '1', '19', '2', '19', '20')||substr(jumin_num,1,6) asc

		) zxcvb) where RNUM<=5 and RNUM>=2
	);        
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<163> employee와 똑같은 구조와 똑같은 데이터를 가진 쌍둥이 테이블 employee2 만들면?
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
-----------------------------------------------------------------------------
	create table employee2 as select * from employee;
-----------------------------------------------------------------------------
위 SQL구문은 select 결과물을 실존 테이블로 만드는 SQL 구문이다.
위 SQL구문으로 테이블 복사하면 컬럼명, 데이터, 자료형, 자료형크기, not null 제약 조건만 그대로 복사된다.
<주의> not null 제약 조건 이외의 제약 조건은 따라오지 않는다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<164> employee와 똑같은 구조를 가진 쌍둥이 테이블 employee3 만들되 데이터는 복사해 오지 않으려면
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
-----------------------------------------------------------------------------
	create table employee3 as select * from employee where 1=2;
-----------------------------------------------------------------------------
where 조건절에 계속 false가 되는 조건을 걸면 컬럼명, 자료형, 자료형크기, not null 제약 조건만 그대로 복사되고
데이터는 복사되지 않는다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<165> 게시판에 입력되는 데이터를 저장하려면 테이블 구조는 어떻게 설계해야 하는가
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
create table board(
b_no		number(9)			-> 게시판 글 고유번호

, subject		varchar2(50)	not null		-> 글 제목
, writer		varchar2(30)	not null		-> 저자 이름
, content		varchar2(2000)	not null		-> 글 내용
, pwd		varchar2(12)	not null		-> 암호 -- 수정 또는 삭제를 위해
, email		varchar2(30)			-> 이메일

, reg_date		date		default sysdate	-> 등록일	
, readcount	number(5)	default 0		-> 조회수	-update

, group_no 	number(9)	not null		-> 게시판 글의 소속 그룹번호.		--정렬 시 사용
, print_no		number(9)	not null		-> 같은 그룹번호 내에서 화면 출력 순서 번호.	--정렬 시 사용

, print_level	number(9)	not null		-> 같은 그룹번호 내에서 댓글 들여쓰기 레벨 단계 번호--부모 자식 관계 확인 가능

, primary key(b_no)
)
------------------------------------------------------------------------------------------------------------------
<새끼> 정렬에 관련된 컬럼은? 
	group by, print_no
	정렬 시
	먼저 그룹번호를 내림차순으로 정렬하고 
	같은 그룹번호 내에서 화면 출력 순서를 오름차순으로 정렬할 것이다.
<새끼> 부모자식 관계를 표현하는데 사용되는 데이터가 있는 컬럼은? 
	print_level
	자식은 부모보다 1단계 오른쪽으로 밀려 들어가게 만든다.

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<166> 게시판이 오픈된 후 처음으로 누군가 아래처럼 글을 올렸다. insert구문을 쓰면?  <- insert 구문 외워둘 것.
									 디폴트로 설정된 컬럼은 안쓰는게 낫다
글제목 => 11월 모두 취업합시다
글내용 => 어쩌구 어쩌구
글쓴이 => 회원
이메일 => hwon@naver.com
비밀번호 => 1234
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
insert into board(
	b_no
	, subject
	, writer
	, content
	, pwd
	. email
	--, reg_date
	--, readcount
	, group_no
	, print_no
	, print_level
)
values(
	(select nvl(max(b_no),0)+1 from board)
	, '11월 모두 취업합시다'
	, '회원'
	, '어쩌구 저쩌구'
	, '1234'
	, 'hwon@naver.com'
	--, sysdate
	--, 0
	, (select nvl(max(b_no),0)+1 from board)
	, 0
	, 0
)

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<167> 누군가 아래처럼 글을 씀. 게시판 번호 1번에 댓글을 아래처럼 올림. 이때 댓글 올리는 과정 중에 발생되는 SQL구문 모두 사용
글제목 => 맞습니다. 열공합시다
글내용 => 어쩌구 어쩌구
글쓴이 => 영민
이메일 => min@naver.com
비밀번호 => 2345
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
부모글의 조회수를 1 업데이트 하기
밑으로 내리는 글의 출력순서번호를 1 업데이트 하기
댓글 입력하기

update board set readcount = readcount + 1 where b_no=1;
-------------------------------------------------------------------------------------
update board set print_no=priont_no+1 
where group_no=b_no가 1번인 글의 그룹번호
	print_no>b_no가 1번인 글의 출력순서번호
-------------------------------------------------------------------------------------
update board set print_no=priont_no+1 
where group_no=(select group_no from board where b_no=1)	-->b_no가 1번인 글의 그룹번호
	print_no>(select print_no from board where b_no=1);	-->b_no가 1번인 글의 출력순서번호
-------------------------------------------------------------------------------------
insert into board(
	b_no
	, subject
	, writer
	, content
	, pwd
	, email
	, group_no
	, print_no
	, print_level
)
values(
	(select nvl(max(b_no),0)+1 from board)
	, '맞습니다. 열공합시다'
	, '영민'
	, '어쩌구 저쩌구'
	, '2345'
	, 'min@naver.com'
	, (select group_no from board where b_no=1)		--b_no가 1번인글의 그룹번호
	, (select print_no+1 from board where b_no=1)		--b_no가 1번인글의 출력순서번호에 1 더한거
	, (select print_level+1 from board where b_no=1)	--b_no가 1번인글의 들여쓰기번호에 1 더한거
)

■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<168> 게시판의 모든 글을 출력하라
---------------------------------------------------	
출력되는 데이터는 단순역순번호, 제목, 글쓴이, 작성일(년-월-일), 조회수 이다
------------------------------------------------------------------------------------------------------
	정렬 기준
---------------------------------------------------
		그룹번호 내림차순
		출력순서번호 오름차순
---------------------------------------------------
	print_level 컬럼안의 데이터를 가지고 들여쓰기를 표현하십쇼		
■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■
<lpad활용 출력식>

select
	x.cnt-rownum+1							"번호", b.*
from
(
	select
		lpad( ' ', print_level*5, ' ' )||decode(print_no,0,'','ㄴ')||subject 	"글제목"
		, writer							"글쓴이명"
		, to_char(reg_date, 'YYYY-MM-DD')				"등록일"
		, readcount						"조회수"
	from
		board 
	order by 
		group_no asc, print_no desc;
) b, (select count(*) CNT from board) x

-------------------------------------------------------------------------------------------------------------

select
	(select count(*) from employee)-rownum+1	no_desc
	, rownum					no_asc
	, e.*
from
	employee e
부하가 많이 걸린다는 단점 존재
-------------------------------------------------------------------------------------------------------------
select
	x.cnt-rownum+1				no_desc
	, rownum					no_asc
	, e.*
from
	employee e, (select count(*) from employee) x

총 갯수와 직원번호 최대값 매칭이 안될 수 있으므로 cnt로 구해야 함

<번외> 10번 부서 직원들이 관리하는 [고객번호], [고객명], [직원번호] 검색
----------------------------------------------------------------------------------------
select
	c.cus_no, c.cus_name, c.emp_no
from
	customer c
where
	exists ( select e.emp_no from employee e
		where e.emp_no = c.emp_no and e.emp_no=10);
----------------------------------------------------------------------------------------
select
	c.cus_no, c.cus_name, c.emp_no
from
	customer c
where
	exists ( select 1 from employee e
		where e.emp_no = c.emp_no and e.dep_no=10);
----------------------------------------------------------------------------------------







<java 문제>
class A {
	int x;
	boolean check() {
		x++;
		return true;
	}
	void zzz() {
		x=0;
		if((check() | check() || check()) {
			x++;
		}
		System.out.println("x = " + x);
	}
}
public class AExe {
	pulbic static void main(String[] args) {
		(new A()).zzz();|
	}
}


<88> 고객번호, 고객명, 고객담당직원이름 검색

select
	c.cus_no				"고객번호"
	,c.cus_name			"고객명"
	,e.emp_name			"고객담당직원이름"
from
	customer c, employee e
where
	c.emp_no=e.emp_no
---------------------------------------------------------------------------------------------------

select
	c.cus_no				"고객번호"
	,c.cus_name			"고객명"
	,e.emp_name			"고객담당직원이름"
from
	customer c, employee e
where
	c.emp_no=e.emp_no(+) --- 딸려나오는 테이블에 나오는 컬럼 오른쪽에 붙음 
				조건에 해당하지 않는 null값 데이터도 끌고와서 검색


<89> 평균 연봉보다 많이 받는 직원 검색

select * from employee where salary >= (select avg(salary) from employee)

비 상관 커리
select 문 안에 select 문을 다시 넣음

<90> 직급별, 평균 연봉 검색

select
	jikup
	,avg(salary)
from
	employee
group by
	jikup


기본적으로 null값을 제외하고 검색하므로 null값 포함하기 위해서 추가적으로 null함수를 추가한다

날짜 함수 정리( 리턴값의 자료형을 조심할것 )
----------------------------------------------------------------------------------------------------------------------
months_between(날짜1, 날짜2) =>날짜1 과 날짜2 의 차이를 개월수로 리턴하기
----------------------------------------------------------------------------------------------------------------------
add_months(날짜,개월수)	   =>날짜에 개월수 만큼 더한 날의 날짜를 리턴하기
----------------------------------------------------------------------------------------------------------------------
last_day(날짜)		   =>날짜가 속한 달의 마지막 날짜를 리턴하기
----------------------------------------------------------------------------------------------------------------------
next_day(날짜, 요일정수)	   =>날짜 기준으로 돌아오는 요일의 날짜를 리턴하기
			       요일 정수는 1~7(일~토)
----------------------------------------------------------------------------------------------------------------------
날짜1-날짜2		   =>날짜1 과 날짜2 의 차이를 일수로 리턴하기
----------------------------------------------------------------------------------------------------------------------
날짜+정수		   =>날짜에다 정수만큼의 일수를 더한 만큼의 날의 날짜를 리턴하기
----------------------------------------------------------------------------------------------------------------------
날짜-정수			   =>날짜에다 정수만큼의 일수를 뺀 만큼의 날의 날짜를 리턴하기


----------------------------------------------------------------------------------------------------------------------
round(숫자저장컬럼명, 반올림한 후 보여지는 자릿수) => round(susdate-hire_date,1)
						소수2자리에서 반올림한 결과 리턴
----------------------------------------------------------------------------------------------------------------------
trunc(숫자저장컬럼명, 버린 후 보여지는 자릿수) => trunc(susdate-hire_date,1)
						소수2자리 이후 모두 버리고 리턴
----------------------------------------------------------------------------------------------------------------------





Xxx x = new 

? y =x.abc(); (입) 상속관계에서 봤을때 최상위에 object가 있으므로 

에러 = abc리턴 값이 void = 리턴 값이 없단 뜻





올해 생일을 찍는 경우 생일이 지금 이 시간보다 이후면 올해 생일 찍어야, 지금 이 시간보다 이전이면 내년 생일을 찍어야

<주의> null값 있는 데이터 검색 = is , null값 없는 데이터 검색 = is not 

원본데이터에는 곱하기등의 다른 행동이 가해지지 않음

오라클 함수 : 




create table dept(						]
 dep_no      	number(3)     	 			]
 ,dep_name  	varchar2(20)    	 not null unique		] 중요
 ,loc       	varchar2(20)   	 not null			]
 ,primary key(dep_no)					]
);							]

-------중요-------
Insert <into> dept(dep_no, dep_name, loc) values(10, '청무부', '서울');
Insert into dept(dep_no, dep_name, loc) values(20, '영업부', '부산');
Insert into dept(dep_no, dep_name, loc) values(30, '전산부', '대전');
Insert into dept(dep_no, dep_name, loc) values(40, '자재부', '광주');

select * from dept

commit;

drop table dept;

 create table employee(
   emp_no           number(3)
   ,emp_name       varchar2(20)     not null
   ,dep_no           number(3)
   ,jikup       	varchar2(20)     not null
   ,salary     	number(9)       default 0
   ,hire_date   	date              default  sysdate
   ,jumin_num       char(13)          not null unique
   ,phone_num      varchar2(15)     not null
   ,mgr_emp_no    number(3)

   , primary key(emp_no)
   , foreign key(dep_no) references dept(dep_no)
   , constraint employee_mgr_emp_no_fk foreign key(mgr_emp_no) references employee(emp_no)
);

 select * from employee;

 --fk 제약조건 끄기
alter table employee disable constraint employee_mgr_emp_no_fk;

  --------------------------------------------
--●날짜 데이터는 '년-월-일'  로 입력 가능하게 하기
--------------------------------------------
alter session set nls_date_format = 'yyyy-mm-dd' ;

--------중요-------
insert <into> employee values( 1, '홍길동', 10, '사장', 5000, '1980-01-01', '7211271109410', '01099699515', null );
insert into employee values( 2, '한국남', 20, '부장', 3000, '1988-11-01', '6002061841224', '01024948424', 1 );
insert into employee values( 3, '이순신', 20, '과장', 3500, '1989-03-01', '6209172010520', '01026352672', 2 );
insert into employee values( 4, '이미라', 30, '대리', 2503, '1983-04-01', '8409282070226', '01094215694', 17 );
insert into employee values( 5, '이순라', 20, '사원', 1200, '1990-05-01', '8401041483626', '01028585900', 3 );
insert into employee values( 6, '공부만', 30, '과장', 4003, '1995-05-01', '8402121563616', '01191338328', 17 );
insert into employee values( 7, '놀기만', 20, '과장', 2300, '1996-06-01', '8011221713914', '01029463523', 2 );
insert into employee values( 8, '채송화', 30, '대리', 1703, '1992-06-01', '8105271014112', '01047111052', 17 );
insert into employee values( 9, '무궁화', 10, '사원', 1100, '1984-08-01', '8303291319116', '01025672300', 12 );
insert into employee values( 10, '공부해', 30, '사원', 1303, '1988-11-01', '8410031281312', '01027073174', 4 );
insert into employee values( 11, '류별나', 20, '과장', 1600, '1989-12-01', '8409181463545', '01071628290', 2 );
insert into employee values( 12, '류명한', 10, '대리', 1800, '1990-10-01', '8207211661117', '01042072622', 20 );
insert into employee values( 13, '무궁화', 10, '부장', 3000, '1996-11-01', '8603231183011', '01098110955', 1 );
insert into employee values( 14, '채시라', 20, '사원', 3400, '1993-10-01', '8001172065410', '01044452437', 3 );
insert into employee values( 15, '최진실', 10, '사원', 2000, '1991-04-01', '8303101932611', '01027491145', 12 );
insert into employee values( 16, '김유신', 30, '사원', 4000, '1981-04-01', '7912031009014', '01098218448', 4 );
insert into employee values( 17, '이성계', 30, '부장', 2803, '1984-05-01', '8102261713921', '0165358075', 1 );
insert into employee values( 18, '강감찬', 30, '사원', 1003, '1986-07-01', '8203121977315', '01033583130', 4 );
insert into employee values( 19, '임꺽정', 20, '사원', 2200, '1988-04-01', '8701301040111', '01086253078', 7 );
insert into employee values( 20, '깨똥이', 10, '과장', 4500, '1990-05-01', '8811232452719', '01090084876', 13 );

commit;
drop table employee;
delete from employee;


<틀린 예시>
create table employee(
     emp_no        number(3)
    ,emp_name      varchar2(20) not null
    ,dep_no        number(3)
    ,jikup         varchar2(20) not null
    ,salary        number(9) default 0
    ,hire_date     date   default sysdate
    ,jumin_num     char(13) not null unique
    ,phone         varchar2(15) not null
    ,mgr_emp_no    number(3)   
        
    ,primary key(emp_no)
    ,foreign key(dep_no) references dept(dep_no)
    ,constraint employee_mgr_emp_no_fk foreign key(mgr_emp_no) references employee(dep_no) - foreign key와 primary key 순서 주의
);

















dept 
=====================================================
dep_no(PK)     dep_name   
=====================================================
10             관리부		---- 지울 수 없음
20             자재부		---- 지울 수 없음
30             홍보부		---- 지울 수 없음
40             사업부		---- 지울 수 없음
50 	    전략부			---- 지울 수 있음 ( 참조하는 FK구간에 해당되는 행이 없으므로)

                  employee 
===============================================================
e_no(PK)     e_name    dep_no(FK)    salary  jikup     mgr_e_no(FK) 
===============================================================
1         사오정       10            5000     대리       3
2         저팔계       20            6000     과장       3
3         손오공       30            7000     부장       null
4         사오정       40            5000     대리       2


            customer 
=====================================================
c_no(PK)     c_name    phone  e_no(FK)
=====================================================
1         사오순        ~     2
2         저팔순        ~     4
3         손오순        ~     1
4         사오순        ~     2


---------------------------------------------------
FK 가 있으면 반드시 PK 가 있다.
---------------------------------------------------
unique 가 걸린 컬럼에는 반드시 not null 이 걸린다..
---------------------------------------------------
자료형도 데이터를 걸러내는데 사용된다.
---------------------------------------------------
not null 이 걸린 컬럼에는 반드시  unique 가 걸린다..
---------------------------------------------------
셀을 삭제하는 명령어는 update 이다.
---------------------------------------------------
행 삭제는 alter 구문이다.
---------------------------------------------------
행 수정은 update 구문이다.
---------------------------------------------------
create 로 만든 테이블은 rollback 으로 없앨수 있다.
---------------------------------------------------
select 도 트랜잭션을 걸수 있다.
---------------------------------------------------
default 가 걸리면 대부분 not null 이다.


포트 번호 :
운영체제에 설치되는 소프트웨어가 통신을 목적으로 운영체제로부터 부여받는 통신번호

	'20211225' - '20210611' --> XX


★
문자함수류들은 우선적으로 외워둘 것




★
둥근 괄호의 활용
먼저 사용될 구문 나눌 때
복잡한 식의 구분


★
현업 개발 일지를 일기 형식으로
메모하는 습관 필요

★
Q 자바에서 " 와 ' 가 언제 사용되는지?
String 형 데이터 에 "
char형 문자 데이터(길이 한자로 해야) 에 '


★
ID - 모든 사람이 균등하게 환경 사용
계정 - 개인마다 다른 권한 부여


★철자 주의
컬럼 Column,
트랜잭션 Transaction,
스키마 Schema
질문 Query
절차적 Procedural

★
String name = "아무개";
int age = 5555555;
--------------------------------------------
select b_no , subject from board;

★. 면접 팁 ;
정의, 부연, 예시

정리정돈된 대화 습관--------------------------------------------------------------------




콜렉션 - 서로 다른 객체의 데이터를 저장가능 - 의의로 장점 아님

db 연동할 때 배열의 단점 - db 연동할 때 연동할 (저장하기 전에) 데이터 개수를 미리 알아야 하기 때문에

java null -- 객체의 메모리 위치 주소값이 아직 없다 <<참조형>>

xxx b = null; 잠깐 가지고 있는 더미데이터(추후에 다른 데이터가 들어갈 예정) 


추후에 고칠 부분 (, . 표시 잘할것)

select
	d.dep_no					"부서번호"
	, d.dep_name				"부서명"
	, count(distinct (e.emp_no))				"직원수"
	, count(c.emp_no)				"관리고객수" 
from	dept d, employee e, customer c
where	d.dep_no=e.dep_no(+) and c.emp_no(+)=e.emp_no
group by
	d.dep_no, d.dep_name;

select
	d.dep_no					"부서번호"
	, d.dep_name				"부서명"
	, count(distinct (e.emp_no))				"직원수"
	, count(c.emp_no)				"관리고객수" 
FROM
	(dept d LEFT OUTER JOIN employee e ON d.dep_no = e.dep_no)
	LEFT OUTER JOIN customer c ON e.emp_no = c.emp_no
GROUP BY d.dep_no, d.dep_name;

---------------------------------------------------------------------------------------
class X {
	public static int a;
	public static void modify(int a) {
		a++;
	}
}
public class XExe {
	public static void main(String[] args) {
		X.modify(X.a);
		System.out.println(X.a);
	}
}
	What is the result?
	A. 0
	B. 1
	C. Compilation fails.
	D. An exception is thrown at runtime.

----------------------------------------------------------------------------------------


integer abc = 3;
integer abc = new integer(3);

참조형 - 기본적으로 null
default 값
int 0
double 0.0
boolean false

--------------------------------------------------------------------------------------
public class Test {
	public static void replaceJ(String text) {
		text.replace('j', 'l');
	}
}
public class TestExe {
	public static void main(String args[]) {
		String text = new String("java");
		Test.replaceJ(text);
		System.out.println(text);
	}
}
	What is the result?
	A. lava
	B. java
	C. Compilation fails.
	D. An exception is thrown at runtime.
--------------------------------------------------------------------------------------
class A {
	public byte getNumber() { return 1; }
}
class B extends A {
	public short getNumber() { return 2; }  //8 
}
class BExe {
	public static void main(String args[]) {
		B b = new B();
		System.out.println(b.getNumber());   //14
	}
}
	What is the result?
	A. 1
	B. 2
	C. An exception is thrown at runtime.
	D. Compilation fails because of an error in line 8.
	E. Compilation fails because of an error in line 14.
----------------------------------------------------------------------------------------------




뉴케어 고소한 맛 30개들이 찾아보기
